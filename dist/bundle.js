/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n    background: #f7fafc;\n}\n\n#app {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    overflow: hidden;\n}\n\n.toolbar {\n    background: #2d3748;\n    padding: 15px 20px;\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    flex-wrap: wrap;\n    flex-shrink: 0;\n}\n\n.resolution-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-left: auto;\n    color: white;\n}\n\n.zoom-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-left: 20px;\n    color: white;\n    padding: 0 15px;\n    border-left: 1px solid #4a5568;\n}\n\n.zoom-controls label {\n    font-size: 18px;\n    cursor: pointer;\n}\n\n.zoom-controls input[type=\"range\"] {\n    width: 150px;\n    cursor: pointer;\n}\n\n.zoom-controls #zoomValue {\n    min-width: 45px;\n    text-align: right;\n    font-size: 14px;\n    color: #cbd5e0;\n}\n\n.resolution-controls label {\n    font-size: 14px;\n}\n\n.resolution-controls input[type=\"number\"] {\n    width: 80px;\n    padding: 5px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    text-align: center;\n}\n\n.resolution-controls span {\n    color: #cbd5e0;\n}\n\n.resolution-select {\n    padding: 5px 10px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    cursor: pointer;\n}\n\n.tool-btn {\n    background: #4a5568;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 14px;\n    transition: all 0.3s ease;\n}\n\n.tool-btn:hover {\n    background: #718096;\n    transform: translateY(-2px);\n}\n\n.tool-btn.danger {\n    background: #e53e3e;\n}\n\n.tool-btn.danger:hover {\n    background: #fc8181;\n}\n\n/* Sync button styles */\n.sync-btn {\n    background: #6c757d;\n    font-weight: bold;\n    transition: all 0.3s ease;\n}\n\n.sync-btn.active {\n    background: #28a745;\n    animation: pulse 1.5s infinite;\n}\n\n.sync-btn:hover {\n    background: #5a6268;\n}\n\n.sync-btn.active:hover {\n    background: #218838;\n}\n\n@keyframes pulse {\n    0% { opacity: 1; }\n    50% { opacity: 0.8; }\n    100% { opacity: 1; }\n}\n\n.tool-btn.primary {\n    background: #3182ce;\n}\n\n.tool-btn.primary:hover {\n    background: #4299e1;\n}\n\n#cropBtn {\n    background: #9f7aea;\n    display: none;\n}\n\n#cropBtn:hover {\n    background: #b794f4;\n}\n\n.toolbar-separator {\n    width: 1px;\n    height: 30px;\n    background: #4a5568;\n    margin: 0 10px;\n}\n\n.canvas-area {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    padding-top: 0;  /* Remove any padding that might affect positioning */\n    transition: none;  /* Prevent animation when toolbar appears */\n}\n\n.canvas-container {\n    flex: 1;\n    background: linear-gradient(to br, #f0f4f8, #e2e8f0);\n    overflow: auto;\n    padding: 100px; /* Increased padding to prevent edge cutting */\n    position: relative;\n    display: grid;\n    grid-template-columns: repeat(auto-fill, max-content);\n    grid-template-rows: repeat(auto-fill, max-content);\n    gap: 50px;\n    justify-content: center;\n    align-items: center;\n}\n\n/* zoom-wrapper removed - not needed */\n\n.canvas-wrapper {\n    flex-shrink: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    margin: 0;\n    width: fit-content;\n    height: fit-content;\n    gap: 8px;\n    position: relative;\n    transform-origin: center center;\n}\n\n.canvas-title {\n    padding: 8px 15px;\n    background: transparent;\n    color: #2d3748;\n    border-radius: 6px;\n    font-size: 14px;\n    font-weight: 500;\n    cursor: text;\n    min-width: 100px;\n    text-align: center;\n    width: auto;\n    display: inline-block;\n    transition: background 0.2s ease;\n}\n\n.canvas-title:hover {\n    background: #f7fafc;\n}\n\n.canvas-title:focus {\n    outline: 2px solid #3182ce;\n    outline-offset: -2px;\n}\n\n.canvas-content {\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n    padding: 0;\n    cursor: pointer;\n    transition: box-shadow 0.2s ease;\n    position: relative;\n}\n\n.canvas-content:hover {\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n}\n\n.canvas-wrapper.active .canvas-content {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 8px rgba(0,0,0,0.2);\n    cursor: default;\n}\n\n.canvas-wrapper.drag-over .canvas-content {\n    box-shadow: 0 0 0 3px #10b981, 0 4px 12px rgba(16, 185, 129, 0.3);\n    background: rgba(16, 185, 129, 0.02);\n}\n\n.canvas-content canvas {\n    background: white;\n    cursor: default;\n    image-rendering: crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -webkit-optimize-contrast;\n    display: block;\n    border-radius: 8px;\n    transition: border 0.3s ease, box-shadow 0.3s ease;\n}\n\n.canvas-content canvas.drag-over {\n    border: 3px dashed #3182ce !important;\n    box-shadow: 0 0 20px rgba(49, 130, 206, 0.5) !important;\n}\n\n.canvas-container.dragging {\n    background: #e2e8f0;\n}\n\n.canvas-element {\n    position: absolute;\n    cursor: move;\n    border: 2px solid transparent;\n    padding: 5px;\n    user-select: none;\n}\n\n.canvas-element:hover {\n    border-color: #4299e1;\n}\n\n.canvas-element.selected {\n    border-color: #3182ce;\n    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);\n}\n\n.canvas-element.text {\n    font-size: 24px;\n    color: #2d3748;\n    background: transparent;\n    min-width: 100px;\n    min-height: 30px;\n}\n\n.canvas-element.image {\n    max-width: 300px;\n    max-height: 300px;\n}\n\n.canvas-element img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 10px;\n    height: 10px;\n    background: #3182ce;\n    border: 2px solid white;\n    border-radius: 50%;\n}\n\n.resize-handle.bottom-right {\n    bottom: -5px;\n    right: -5px;\n    cursor: nwse-resize;\n}\n\n.delete-btn {\n    position: absolute;\n    top: -10px;\n    right: -10px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    line-height: 1;\n}\n\n.delete-btn:hover {\n    background: #fc8181;\n}\n\n.text-toolbar {\n    position: fixed;\n    top: 60px;  /* Below main toolbar */\n    left: 0;\n    right: 0;\n    background: #4a5568;\n    padding: 12px 15px;\n    border-bottom: 1px solid #2d3748;\n    z-index: 1000;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n}\n\n.text-controls {\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    justify-content: center;\n}\n\n.text-select {\n    padding: 5px 10px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    cursor: pointer;\n}\n\n.font-size-input {\n    width: 60px;\n    padding: 5px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    text-align: center;\n}\n\n.format-btn {\n    width: 30px;\n    height: 30px;\n    border: none;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.format-btn.italic {\n    font-style: italic;\n}\n\n.format-btn:hover,\n.format-btn.active {\n    background: #3182ce;\n}\n\n.align-group {\n    display: flex;\n    gap: 5px;\n    background: #2d3748;\n    padding: 3px;\n    border-radius: 4px;\n}\n\n.align-btn {\n    width: 30px;\n    height: 26px;\n    border: none;\n    background: transparent;\n    color: white;\n    cursor: pointer;\n    border-radius: 3px;\n    transition: all 0.2s;\n}\n\n.align-btn:hover,\n.align-btn.active {\n    background: #3182ce;\n}\n\n.color-picker {\n    width: 40px;\n    height: 30px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n    background: #3182ce;\n    border: 1px solid white;\n    border-radius: 2px;\n    cursor: pointer;\n}\n\n.resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }\n.resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }\n.resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }\n.resize-handle.e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }\n.resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }\n.resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }\n.resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }\n.resize-handle.w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }\n\n.context-menu {\n    position: fixed;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    z-index: 10000;\n    min-width: 200px;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n}\n\n.context-menu-item {\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: background-color 0.1s;\n    display: flex;\n    align-items: center;\n    color: #2d3748;\n    position: relative;\n}\n\n.context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.context-menu-item span:first-child {\n    width: 20px;\n    text-align: center;\n    margin-right: 8px;\n}\n\n.context-menu-item .shortcut {\n    margin-left: auto;\n    opacity: 0.6;\n    font-size: 11px;\n    padding-left: 20px;\n}\n\n.context-menu-item:hover .shortcut {\n    opacity: 0.9;\n}\n\n.context-menu-separator {\n    height: 1px;\n    background-color: #e2e8f0;\n    margin: 4px 0;\n}\n\n.context-menu-item.has-submenu {\n    position: relative;\n    padding-right: 25px;\n}\n\n.context-menu-item .submenu-arrow {\n    position: absolute;\n    right: 8px;\n    opacity: 0.5;\n    width: auto;\n    margin: 0;\n}\n\n.context-submenu {\n    position: absolute;\n    left: 100%;\n    top: -4px;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    min-width: 180px;\n    display: none;\n}\n\n.context-menu-item.has-submenu:hover .context-submenu {\n    display: block;\n}\n\n.context-submenu .context-menu-item {\n    padding: 8px 12px;\n}\n\n.context-submenu .context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.thumbnail-bar {\n    position: relative;\n    background: #2d3748;\n    border-top: 1px solid #1a202c;\n    transition: height 0.3s ease;\n    overflow: hidden;\n    height: 180px;\n}\n\n.thumbnail-bar.collapsed {\n    height: 40px;\n}\n\n.thumbnail-toggle {\n    position: absolute;\n    top: 8px;\n    left: 50%;\n    transform: translateX(-50%);\n    z-index: 10;\n    background: #4a5568;\n    border: 1px solid #718096;\n    border-radius: 4px;\n    padding: 6px 10px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    color: white;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.thumbnail-toggle:hover {\n    background: #5a6578;\n    border-color: #828a96;\n}\n\n.thumbnail-bar.collapsed .thumbnail-toggle svg {\n    transform: rotate(180deg);\n}\n\n.thumbnail-grid-container {\n    display: grid;\n    grid-template-columns: repeat(10, 140px);\n    grid-template-rows: repeat(10, 110px);\n    gap: 15px;\n    padding: 50px 20px 20px 20px;\n    overflow: auto;\n    height: 100%;\n    width: 100%;\n    align-content: start;\n    justify-content: start;\n}\n\n.thumbnail-item {\n    position: relative;\n    width: 120px;\n    height: 90px;\n    background: white;\n    border-radius: 6px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.2s;\n}\n\n.thumbnail-item:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n}\n\n.thumbnail-item.active {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 4px rgba(0,0,0,0.2);\n}\n\n.thumbnail-canvas {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.thumbnail-label {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: rgba(0,0,0,0.7);\n    color: white;\n    padding: 2px 5px;\n    font-size: 11px;\n    text-align: center;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.thumbnail-delete {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: none;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n}\n\n.thumbnail-item:hover .thumbnail-delete {\n    display: flex;\n}\n\n.thumbnail-delete:hover {\n    background: #fc8181;\n}\n\n.canvas-link-button {\n    position: absolute;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 24px;\n    height: 24px;\n    background: white;\n    border: 1px solid #d1d5db;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: all 0.15s ease;\n    z-index: 100;\n    font-size: 12px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);\n}\n\n.canvas-link-button.horizontal-link {\n    margin: 0;\n}\n\n.canvas-link-button.vertical-link {\n    margin: 0;\n}\n\n.canvas-link-button:hover {\n    background: #f9fafb;\n    border-color: #9ca3af;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.canvas-link-button.active {\n    background: #3b82f6;\n    border-color: #3b82f6;\n    color: white;\n}\n\n.canvas-link-button.active:hover {\n    background: #2563eb;\n    border-color: #2563eb;\n}\n\n.canvas-link-button svg {\n    width: 20px;\n    height: 20px;\n    pointer-events: none;\n}\n\n.canvas-link-button.active svg {\n    stroke: white;\n}\n\n/* Crop mode styles */\n.crop-mode-toolbar {\n    position: fixed;\n    bottom: 140px; /* Above thumbnail bar */\n    left: 50%;\n    transform: translateX(-50%);\n    background: #2d3748;\n    padding: 12px 20px;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    z-index: 10000;\n}\n\n.crop-mode-toolbar button {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 500;\n    transition: all 0.2s;\n}\n\n.crop-mode-toolbar .apply-crop {\n    background: #48bb78;\n    color: white;\n}\n\n.crop-mode-toolbar .apply-crop:hover {\n    background: #38a169;\n    transform: translateY(-1px);\n}\n\n.crop-mode-toolbar .cancel-crop {\n    background: #e53e3e;\n    color: white;\n}\n\n.crop-mode-toolbar .cancel-crop:hover {\n    background: #c53030;\n    transform: translateY(-1px);\n}\n\n.crop-mode-toolbar .crop-info {\n    color: white;\n    font-size: 13px;\n    margin: 0 10px;\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://dynamic-canvas/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/CanvasGridManager.ts":
/*!**********************************!*\
  !*** ./src/CanvasGridManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasGridManager: () => (/* binding */ CanvasGridManager)\n/* harmony export */ });\nclass CanvasGridManager {\n    constructor() {\n        this.grid = new Map(); // \"row,col\" -> canvasId\n        this.canvasPositions = new Map(); // canvasId -> position\n        this.links = new Map(); // linkId -> CanvasLink\n        this.linkStates = new Map(); // \"canvasId1-canvasId2\" -> enabled\n        console.log('[GRID] Canvas Grid Manager initialized');\n    }\n    // Add canvas to grid at specific position\n    addCanvas(canvasId, row, col) {\n        const key = `${row},${col}`;\n        this.grid.set(key, canvasId);\n        this.canvasPositions.set(canvasId, { row, col });\n        console.log(`[GRID] Added canvas ${canvasId} at position (${row}, ${col})`);\n        // Automatically create links with adjacent canvases\n        this.createAdjacentLinks(canvasId, row, col);\n    }\n    // Remove canvas from grid\n    removeCanvas(canvasId) {\n        const position = this.canvasPositions.get(canvasId);\n        if (position) {\n            const key = `${position.row},${position.col}`;\n            this.grid.delete(key);\n            this.canvasPositions.delete(canvasId);\n            // Remove all links involving this canvas\n            this.removeCanvasLinks(canvasId);\n        }\n    }\n    // Get canvas at specific grid position\n    getCanvasAt(row, col) {\n        const key = `${row},${col}`;\n        return this.grid.get(key) || null;\n    }\n    // Get all adjacent canvases (8 directions)\n    getAdjacentCanvases(canvasId) {\n        const position = this.canvasPositions.get(canvasId);\n        if (!position)\n            return new Map();\n        const adjacent = new Map();\n        const directions = [\n            { dir: 'top', dr: -1, dc: 0 },\n            { dir: 'top-right', dr: -1, dc: 1 },\n            { dir: 'right', dr: 0, dc: 1 },\n            { dir: 'bottom-right', dr: 1, dc: 1 },\n            { dir: 'bottom', dr: 1, dc: 0 },\n            { dir: 'bottom-left', dr: 1, dc: -1 },\n            { dir: 'left', dr: 0, dc: -1 },\n            { dir: 'top-left', dr: -1, dc: -1 }\n        ];\n        for (const { dir, dr, dc } of directions) {\n            const adjacentCanvas = this.getCanvasAt(position.row + dr, position.col + dc);\n            if (adjacentCanvas) {\n                adjacent.set(dir, adjacentCanvas);\n            }\n        }\n        return adjacent;\n    }\n    // Create links with adjacent canvases\n    createAdjacentLinks(canvasId, row, col) {\n        const adjacent = this.getAdjacentCanvases(canvasId);\n        adjacent.forEach((adjacentId, direction) => {\n            const linkKey = this.getLinkKey(canvasId, adjacentId);\n            // Check if link already exists\n            if (!this.linkStates.has(linkKey)) {\n                // Create new link (enabled by default)\n                this.linkStates.set(linkKey, true);\n                console.log(`[GRID] Created link between ${canvasId} and ${adjacentId} (${direction})`);\n            }\n        });\n    }\n    // Remove all links for a canvas\n    removeCanvasLinks(canvasId) {\n        const keysToRemove = [];\n        this.linkStates.forEach((_, key) => {\n            if (key.includes(canvasId)) {\n                keysToRemove.push(key);\n            }\n        });\n        keysToRemove.forEach(key => this.linkStates.delete(key));\n    }\n    // Toggle link between two canvases\n    toggleLink(canvas1, canvas2) {\n        const key = this.getLinkKey(canvas1, canvas2);\n        const currentState = this.linkStates.get(key) || false;\n        const newState = !currentState;\n        this.linkStates.set(key, newState);\n        console.log(`[GRID] Link between ${canvas1} and ${canvas2}: ${newState ? 'ENABLED' : 'DISABLED'}`);\n        return newState;\n    }\n    // Check if two canvases are linked\n    areCanvasesLinked(canvas1, canvas2) {\n        const key = this.getLinkKey(canvas1, canvas2);\n        return this.linkStates.get(key) || false;\n    }\n    // Get a consistent key for a link between two canvases\n    getLinkKey(canvas1, canvas2) {\n        // Sort IDs to ensure consistent key regardless of order\n        return [canvas1, canvas2].sort().join('-');\n    }\n    // Find next available position relative to a specific canvas\n    findNextPosition(direction, relativeToCanvasId) {\n        // If no relative canvas specified, use default behavior\n        if (!relativeToCanvasId) {\n            // For first canvas\n            if (this.canvasPositions.size === 0) {\n                return { row: 0, col: 0 };\n            }\n            // Find first available spot\n            return this.findFirstAvailablePosition();\n        }\n        // Get position of reference canvas\n        const refPosition = this.canvasPositions.get(relativeToCanvasId);\n        if (!refPosition) {\n            return this.findFirstAvailablePosition();\n        }\n        // Find position based on direction\n        if (direction === 'right') {\n            // Add to the right of reference canvas\n            let col = refPosition.col + 1;\n            let row = refPosition.row;\n            // Check if position is available\n            while (this.getCanvasAt(row, col)) {\n                col++;\n            }\n            return { row, col };\n        }\n        else {\n            // Add below reference canvas\n            let row = refPosition.row + 1;\n            let col = refPosition.col;\n            // Check if position is available\n            while (this.getCanvasAt(row, col)) {\n                row++;\n            }\n            return { row, col };\n        }\n    }\n    findFirstAvailablePosition() {\n        // Find first available position in grid\n        for (let row = 0; row < 10; row++) {\n            for (let col = 0; col < 10; col++) {\n                if (!this.getCanvasAt(row, col)) {\n                    return { row, col };\n                }\n            }\n        }\n        return { row: 0, col: 0 };\n    }\n    // Get canvas position\n    getCanvasPosition(canvasId) {\n        return this.canvasPositions.get(canvasId) || null;\n    }\n    // Check if element can move between canvases\n    canElementMoveBetweenCanvases(fromCanvas, toCanvas) {\n        // Check if canvases are adjacent\n        const fromPos = this.canvasPositions.get(fromCanvas);\n        const toPos = this.canvasPositions.get(toCanvas);\n        if (!fromPos || !toPos)\n            return false;\n        // Check if adjacent (within 1 cell distance)\n        const rowDiff = Math.abs(fromPos.row - toPos.row);\n        const colDiff = Math.abs(fromPos.col - toPos.col);\n        if (rowDiff > 1 || colDiff > 1)\n            return false;\n        // Check if link is enabled\n        return this.areCanvasesLinked(fromCanvas, toCanvas);\n    }\n}\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/CanvasGridManager.ts?\n}");

/***/ }),

/***/ "./src/CanvasManager.ts":
/*!******************************!*\
  !*** ./src/CanvasManager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasManager: () => (/* binding */ CanvasManager)\n/* harmony export */ });\nclass CanvasManager {\n    constructor(canvasId, globalManager, offsetX = 0, offsetY = 0) {\n        this.offsetX = 0; // Canvas offset in global coordinate system\n        this.offsetY = 0;\n        this.scale = 1;\n        // Linking state is tracked by checking link button status\n        // private editingElementId: string | null = null; // Removed - not needed anymore  // Track element being edited\n        this.cropMode = false; // Track crop mode\n        this.cropHandle = null; // Current crop handle being dragged  \n        this.cropBounds = null;\n        this.cropOriginalBounds = null;\n        this.cropStartPoint = { x: 0, y: 0 }; // Start point for crop dragging\n        this.cropDragging = false; // Track if dragging crop area\n        this.cropResizing = false; // Track if resizing crop area\n        this.cropResizeHandle = ''; // Which resize handle is being dragged\n        this.dragState = {\n            isDragging: false,\n            element: null,\n            startPoint: { x: 0, y: 0 },\n            elementStartPoint: { x: 0, y: 0 }\n        };\n        this.isSelectionDragging = false;\n        this.selectionStartPoint = { x: 0, y: 0 };\n        this.selectionEndPoint = { x: 0, y: 0 };\n        this.originalPositions = new Map();\n        this.resizeState = {\n            isResizing: false,\n            element: null,\n            handle: null,\n            startPoint: { x: 0, y: 0 },\n            originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n        };\n        this.clipboard = null;\n        this.lastContextMenuPosition = { x: 0, y: 0 };\n        this.canvas = document.getElementById(canvasId);\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Failed to get canvas context');\n        }\n        this.ctx = context;\n        this.globalManager = globalManager;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.textToolbar = document.getElementById('textToolbar');\n        this.contextMenu = document.getElementById('contextMenu');\n        this.setupCanvas();\n        this.setupEventListeners();\n        this.setupTextToolbar();\n        this.setupContextMenu();\n        // Listen for linking state changes\n        document.addEventListener('linking-state-changed', (e) => {\n            const customEvent = e;\n            this.render(); // Re-render when linking state changes\n        });\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isLinkingEnabled() {\n        // Check if any link button is active (has 'active' class)\n        const linkButtons = document.querySelectorAll('.canvas-link-button');\n        return Array.from(linkButtons).some(btn => btn.classList.contains('active'));\n    }\n    setOffset(offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.render();\n    }\n    getOffset() {\n        return { x: this.offsetX, y: this.offsetY };\n    }\n    // Convert global coordinates to local canvas coordinates\n    globalToLocal(globalX, globalY) {\n        return {\n            x: globalX - this.offsetX,\n            y: globalY - this.offsetY\n        };\n    }\n    // Convert local canvas coordinates to global coordinates\n    localToGlobal(localX, localY) {\n        return {\n            x: localX + this.offsetX,\n            y: localY + this.offsetY\n        };\n    }\n    setupCanvas() {\n        this.setResolution(800, 600);\n    }\n    setResolution(width, height) {\n        // Store the actual resolution\n        this.canvas.width = width;\n        this.canvas.height = height;\n        // Calculate display size based on aspect ratio and viewport\n        this.updateCanvasDisplaySize();\n        // Re-render with new resolution\n        this.render();\n    }\n    updateCanvasDisplaySize() {\n        const canvasContent = this.canvas.parentElement; // canvas-content\n        if (!canvasContent)\n            return;\n        // Maximum available space (accounting for UI elements)\n        // Subtract space for toolbar (approx 70px), thumbnail bar (120px), title (30px), and some padding\n        const maxAvailableWidth = window.innerWidth - 80; // Some padding for scrollbar\n        const maxAvailableHeight = window.innerHeight - 300; // Toolbar + thumbnail bar + title + padding\n        // Calculate the ideal display size\n        const canvasAspectRatio = this.canvas.width / this.canvas.height;\n        let displayWidth;\n        let displayHeight;\n        // Determine the base scale (trying to show canvas at a reasonable size)\n        // Use a base scale that makes sense for typical screen sizes\n        const baseScale = Math.min(maxAvailableWidth / this.canvas.width, maxAvailableHeight / this.canvas.height, 1.0 // Don't scale up beyond 100%\n        );\n        // Apply the scale\n        displayWidth = this.canvas.width * baseScale;\n        displayHeight = this.canvas.height * baseScale;\n        // Ensure minimum size for usability\n        const minWidth = 400;\n        const minHeight = 300;\n        if (displayWidth < minWidth && displayHeight < minHeight) {\n            // Scale up to minimum size while maintaining aspect ratio\n            const minScale = Math.max(minWidth / this.canvas.width, minHeight / this.canvas.height);\n            displayWidth = this.canvas.width * minScale;\n            displayHeight = this.canvas.height * minScale;\n        }\n        // Final scale for mouse position calculations\n        this.scale = displayWidth / this.canvas.width;\n        // Apply calculated dimensions to canvas display\n        this.canvas.style.width = `${displayWidth}px`;\n        this.canvas.style.height = `${displayHeight}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));\n        this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));\n        // Use document-level mouse move and up for better cross-canvas dragging\n        document.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        document.addEventListener('mouseup', this.handleMouseUp.bind(this));\n        // Add click event to activate canvas when clicked\n        this.canvas.addEventListener('click', (e) => {\n            // Dispatch custom event to notify MultiCanvasManager\n            const event = new CustomEvent('canvas-clicked', {\n                detail: { canvasId: this.canvas.id }\n            });\n            document.dispatchEvent(event);\n        });\n        // Add keyboard event listener for crop mode\n        document.addEventListener('keydown', (e) => {\n            if (this.cropMode) {\n                if (e.key === 'Enter') {\n                    e.preventDefault();\n                    this.applyCrop();\n                }\n                else if (e.key === 'Escape') {\n                    e.preventDefault();\n                    this.cropMode = false;\n                    this.canvas.classList.remove('crop-mode');\n                    this.hideCropToolbar();\n                    this.render();\n                }\n            }\n        });\n        // Add window resize listener for responsive canvas\n        window.addEventListener('resize', () => {\n            this.updateCanvasDisplaySize();\n        });\n        // Listen for linking state changes\n        document.addEventListener('linking-state-changed', (e) => {\n            const customEvent = e;\n            // Linking state changed, re-render\n            this.render();\n            // Re-render when linking state changes\n            this.render();\n        });\n        // Hide context menu when clicking elsewhere\n        document.addEventListener('click', (e) => {\n            if (!this.contextMenu.contains(e.target)) {\n                this.contextMenu.style.display = 'none';\n            }\n        });\n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (e.ctrlKey || e.metaKey) {\n                if (e.key === 'c') {\n                    e.preventDefault();\n                    this.copyElement();\n                }\n                else if (e.key === 'v') {\n                    e.preventDefault();\n                    this.pasteElement();\n                }\n                else if (e.key === 'd') {\n                    e.preventDefault();\n                    this.duplicateElement();\n                }\n            }\n            // Enter key to apply crop\n            if (e.key === 'Enter' && this.cropMode) {\n                e.preventDefault();\n                this.applyCrop();\n            }\n            // Escape key to cancel crop\n            if (e.key === 'Escape' && this.cropMode) {\n                e.preventDefault();\n                this.cropMode = false;\n                this.render();\n            }\n        });\n    }\n    setupTextToolbar() {\n        const fontFamily = document.getElementById('fontFamily');\n        const fontSize = document.getElementById('fontSize');\n        const boldBtn = document.getElementById('boldBtn');\n        const italicBtn = document.getElementById('italicBtn');\n        const alignLeft = document.getElementById('alignLeft');\n        const alignCenter = document.getElementById('alignCenter');\n        const alignRight = document.getElementById('alignRight');\n        const textColor = document.getElementById('textColor');\n        fontFamily?.addEventListener('change', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontFamily: fontFamily.value });\n                this.render();\n            }\n        });\n        fontSize?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontSize: parseInt(fontSize.value) });\n                this.render();\n            }\n        });\n        boldBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontWeight: selectedElement.fontWeight === 'bold' ? 'normal' : 'bold'\n                });\n                boldBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        italicBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontStyle: selectedElement.fontStyle === 'italic' ? 'normal' : 'italic'\n                });\n                italicBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        const alignButtons = [alignLeft, alignCenter, alignRight];\n        const alignValues = ['left', 'center', 'right'];\n        alignButtons.forEach((btn, index) => {\n            btn?.addEventListener('click', () => {\n                const selectedElement = this.globalManager.getSelectedElement();\n                if (selectedElement?.type === 'text') {\n                    this.globalManager.updateElement(selectedElement.id, { textAlign: alignValues[index] });\n                    alignButtons.forEach(b => b?.classList.remove('active'));\n                    btn.classList.add('active');\n                    this.render();\n                }\n            });\n        });\n        textColor?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { color: textColor.value });\n                this.render();\n            }\n        });\n    }\n    updateTextToolbar() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement?.type === 'text') {\n            this.textToolbar.style.display = 'block';\n            const fontFamily = document.getElementById('fontFamily');\n            const fontSize = document.getElementById('fontSize');\n            const boldBtn = document.getElementById('boldBtn');\n            const italicBtn = document.getElementById('italicBtn');\n            const textColor = document.getElementById('textColor');\n            const alignButtons = [\n                document.getElementById('alignLeft'),\n                document.getElementById('alignCenter'),\n                document.getElementById('alignRight')\n            ];\n            if (fontFamily)\n                fontFamily.value = selectedElement.fontFamily || 'Arial';\n            if (fontSize)\n                fontSize.value = (selectedElement.fontSize || 24).toString();\n            if (textColor)\n                textColor.value = selectedElement.color || '#2d3748';\n            boldBtn?.classList.toggle('active', selectedElement.fontWeight === 'bold');\n            italicBtn?.classList.toggle('active', selectedElement.fontStyle === 'italic');\n            const alignIndex = ['left', 'center', 'right'].indexOf(selectedElement.textAlign || 'left');\n            alignButtons.forEach((btn, i) => {\n                btn?.classList.toggle('active', i === alignIndex);\n            });\n        }\n        else {\n            this.textToolbar.style.display = 'none';\n        }\n    }\n    handleMouseDown(e) {\n        // First, activate this canvas\n        const event = new CustomEvent('canvas-clicked', {\n            detail: { canvasId: this.canvas.id }\n        });\n        document.dispatchEvent(event);\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        // CROP MODE: Only allow crop handle dragging, disable ALL other mouse functions\n        if (this.cropMode) {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && selectedElement.type === 'image' && this.cropBounds) {\n                const localX = selectedElement.x - this.offsetX;\n                const localY = selectedElement.y - this.offsetY;\n                const mouseX = localPoint.x - localX;\n                const mouseY = localPoint.y - localY;\n                // Check if click is outside the image bounds - if so, apply crop\n                if (mouseX < 0 || mouseY < 0 ||\n                    mouseX > selectedElement.width || mouseY > selectedElement.height) {\n                    console.log('[CROP] Click outside image - applying crop');\n                    this.applyCrop();\n                    return;\n                }\n                // Check which edge/corner is being clicked (20px threshold for easier clicking)\n                const threshold = 20;\n                const bounds = this.cropBounds;\n                const nearLeft = Math.abs(mouseX - bounds.left) < threshold;\n                const nearRight = Math.abs(mouseX - bounds.right) < threshold;\n                const nearTop = Math.abs(mouseY - bounds.top) < threshold;\n                const nearBottom = Math.abs(mouseY - bounds.bottom) < threshold;\n                // Determine handle (corners have priority)\n                if (nearLeft && nearTop) {\n                    this.cropHandle = 'nw';\n                }\n                else if (nearRight && nearTop) {\n                    this.cropHandle = 'ne';\n                }\n                else if (nearRight && nearBottom) {\n                    this.cropHandle = 'se';\n                }\n                else if (nearLeft && nearBottom) {\n                    this.cropHandle = 'sw';\n                }\n                else if (nearLeft) {\n                    this.cropHandle = 'w';\n                }\n                else if (nearRight) {\n                    this.cropHandle = 'e';\n                }\n                else if (nearTop) {\n                    this.cropHandle = 'n';\n                }\n                else if (nearBottom) {\n                    this.cropHandle = 's';\n                }\n                if (this.cropHandle) {\n                    console.log(`[CROP] Handle detected: ${this.cropHandle}`);\n                    this.cropOriginalBounds = { ...this.cropBounds };\n                }\n                else {\n                    console.log(`[CROP] No handle detected at mouse position`);\n                }\n            }\n            else if (this.cropMode) {\n                // No selected image or click outside any image - apply crop and exit crop mode\n                console.log('[CROP] Click in empty space - applying crop');\n                this.applyCrop();\n            }\n            // In crop mode, stop here - no dragging, no selection, no other interactions\n            return;\n        }\n        // Get element at global position\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element && !this.cropMode) { // Skip resize check in crop mode\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            if (handle) {\n                this.resizeState = {\n                    isResizing: true,\n                    element: element,\n                    handle: handle,\n                    startPoint: globalPoint,\n                    originalBounds: {\n                        x: element.x,\n                        y: element.y,\n                        width: element.width,\n                        height: element.height,\n                        originalFontSize: element.fontSize\n                    }\n                };\n            }\n            else {\n                // Check if Shift or Cmd/Ctrl is held for multi-selection\n                if (e.shiftKey || e.metaKey || e.ctrlKey) {\n                    // Toggle selection\n                    if (this.globalManager.isSelected(element.id)) {\n                        this.globalManager.removeFromSelection(element.id);\n                    }\n                    else {\n                        this.globalManager.addToSelection(element.id);\n                    }\n                }\n                else {\n                    // Single selection\n                    this.globalManager.clearSelection();\n                    this.globalManager.setSelectedElement(element.id);\n                }\n                this.dragState = {\n                    isDragging: true,\n                    element: element,\n                    startPoint: globalPoint,\n                    elementStartPoint: { x: element.x, y: element.y }\n                };\n                // Store original positions of all selected elements for multi-drag\n                this.originalPositions.clear();\n                const selectedElements = this.globalManager.getSelectedElements();\n                selectedElements.forEach(el => {\n                    this.originalPositions.set(el.id, { x: el.x, y: el.y });\n                });\n                this.updateTextToolbar();\n                // Dispatch selection changed event\n                const event = new CustomEvent('selection-changed', {\n                    detail: { element: element }\n                });\n                document.dispatchEvent(event);\n            }\n        }\n        else if (!this.cropMode) { // Only allow selection rectangle when NOT in crop mode\n            // Start selection rectangle if not clicking on an element\n            if (!e.shiftKey && !e.metaKey && !e.ctrlKey) {\n                this.globalManager.clearSelection();\n            }\n            // Start selection dragging\n            this.isSelectionDragging = true;\n            this.selectionStartPoint = globalPoint;\n            this.selectionEndPoint = globalPoint;\n            this.updateTextToolbar();\n            // Dispatch selection changed event with null\n            const event = new CustomEvent('selection-changed', {\n                detail: { element: null }\n            });\n            document.dispatchEvent(event);\n        }\n        this.render();\n    }\n    getCropHandle(point, element) {\n        if (!element.cropX || element.cropX === undefined)\n            return null;\n        const localX = element.x - this.offsetX;\n        const localY = element.y - this.offsetY;\n        const handleSize = 10;\n        const halfSize = handleSize / 2;\n        const cropY = element.cropY || 0;\n        const cropWidth = element.cropWidth || 0;\n        const cropHeight = element.cropHeight || 0;\n        const handles = [\n            { x: localX + element.cropX, y: localY + cropY, type: 'nw' },\n            { x: localX + element.cropX + cropWidth / 2, y: localY + cropY, type: 'n' },\n            { x: localX + element.cropX + cropWidth, y: localY + cropY, type: 'ne' },\n            { x: localX + element.cropX + cropWidth, y: localY + cropY + cropHeight / 2, type: 'e' },\n            { x: localX + element.cropX + cropWidth, y: localY + cropY + cropHeight, type: 'se' },\n            { x: localX + element.cropX + cropWidth / 2, y: localY + cropY + cropHeight, type: 's' },\n            { x: localX + element.cropX, y: localY + cropY + cropHeight, type: 'sw' },\n            { x: localX + element.cropX, y: localY + cropY + cropHeight / 2, type: 'w' }\n        ];\n        for (const handle of handles) {\n            if (point.x >= handle.x - halfSize && point.x <= handle.x + halfSize &&\n                point.y >= handle.y - halfSize && point.y <= handle.y + halfSize) {\n                return handle.type;\n            }\n        }\n        return null;\n    }\n    getCursorForCropHandle(handle) {\n        const cursors = {\n            'nw': 'nw-resize',\n            'n': 'n-resize',\n            'ne': 'ne-resize',\n            'e': 'e-resize',\n            'se': 'se-resize',\n            's': 's-resize',\n            'sw': 'sw-resize',\n            'w': 'w-resize'\n        };\n        return cursors[handle] || 'default';\n    }\n    handleCropDrag(currentPoint, element) {\n        if (element.cropX === undefined || element.cropY === undefined)\n            return;\n        const dx = currentPoint.x - this.cropStartPoint.x;\n        const dy = currentPoint.y - this.cropStartPoint.y;\n        let newCropX = element.cropX + dx;\n        let newCropY = element.cropY + dy;\n        // Constrain within image bounds\n        newCropX = Math.max(0, Math.min(newCropX, element.width - (element.cropWidth || 0)));\n        newCropY = Math.max(0, Math.min(newCropY, element.height - (element.cropHeight || 0)));\n        this.globalManager.updateElement(element.id, {\n            cropX: newCropX,\n            cropY: newCropY\n        });\n        this.cropStartPoint = currentPoint;\n    }\n    handleCropResize(currentPoint, element) {\n        if (element.cropX === undefined || element.cropY === undefined ||\n            element.cropWidth === undefined || element.cropHeight === undefined)\n            return;\n        const dx = currentPoint.x - this.cropStartPoint.x;\n        const dy = currentPoint.y - this.cropStartPoint.y;\n        let newCropX = element.cropX;\n        let newCropY = element.cropY;\n        let newCropWidth = element.cropWidth;\n        let newCropHeight = element.cropHeight;\n        // Update based on which handle is being dragged\n        switch (this.cropResizeHandle) {\n            case 'nw':\n                newCropX += dx;\n                newCropY += dy;\n                newCropWidth -= dx;\n                newCropHeight -= dy;\n                break;\n            case 'n':\n                newCropY += dy;\n                newCropHeight -= dy;\n                break;\n            case 'ne':\n                newCropY += dy;\n                newCropWidth += dx;\n                newCropHeight -= dy;\n                break;\n            case 'e':\n                newCropWidth += dx;\n                break;\n            case 'se':\n                newCropWidth += dx;\n                newCropHeight += dy;\n                break;\n            case 's':\n                newCropHeight += dy;\n                break;\n            case 'sw':\n                newCropX += dx;\n                newCropWidth -= dx;\n                newCropHeight += dy;\n                break;\n            case 'w':\n                newCropX += dx;\n                newCropWidth -= dx;\n                break;\n        }\n        // Ensure minimum size\n        const minSize = 20;\n        if (newCropWidth < minSize) {\n            if (this.cropResizeHandle.includes('w')) {\n                newCropX = element.cropX + element.cropWidth - minSize;\n            }\n            newCropWidth = minSize;\n        }\n        if (newCropHeight < minSize) {\n            if (this.cropResizeHandle.includes('n')) {\n                newCropY = element.cropY + element.cropHeight - minSize;\n            }\n            newCropHeight = minSize;\n        }\n        // Constrain within image bounds\n        newCropX = Math.max(0, newCropX);\n        newCropY = Math.max(0, newCropY);\n        newCropWidth = Math.min(newCropWidth, element.width - newCropX);\n        newCropHeight = Math.min(newCropHeight, element.height - newCropY);\n        this.globalManager.updateElement(element.id, {\n            cropX: newCropX,\n            cropY: newCropY,\n            cropWidth: newCropWidth,\n            cropHeight: newCropHeight\n        });\n        this.cropStartPoint = currentPoint;\n    }\n    handleMouseMove(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        // Handle crop mode - drag handles to crop\n        if (this.cropMode && this.cropHandle && this.cropBounds) {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && selectedElement.type === 'image') {\n                const localX = selectedElement.x - this.offsetX;\n                const localY = selectedElement.y - this.offsetY;\n                const mouseX = Math.max(0, Math.min(localPoint.x - localX, selectedElement.width));\n                const mouseY = Math.max(0, Math.min(localPoint.y - localY, selectedElement.height));\n                // Update crop bounds based on which handle is being dragged\n                const bounds = { ...this.cropBounds };\n                // Update the appropriate edge based on handle\n                if (this.cropHandle.includes('n'))\n                    bounds.top = mouseY;\n                if (this.cropHandle.includes('s'))\n                    bounds.bottom = mouseY;\n                if (this.cropHandle.includes('w'))\n                    bounds.left = mouseX;\n                if (this.cropHandle.includes('e'))\n                    bounds.right = mouseX;\n                // Ensure minimum size of 20px\n                const minSize = 20;\n                if (bounds.right - bounds.left >= minSize && bounds.bottom - bounds.top >= minSize) {\n                    this.cropBounds = bounds;\n                    // Don't update element crop values during drag - only update bounds\n                    // The actual crop values are only set when applyCrop is called\n                    // Update crop info display\n                    this.updateCropInfo();\n                }\n                this.render();\n                return;\n            }\n        }\n        // Handle selection rectangle dragging\n        if (this.isSelectionDragging) {\n            this.selectionEndPoint = globalPoint;\n            // Calculate selection rectangle bounds\n            const x = Math.min(this.selectionStartPoint.x, this.selectionEndPoint.x);\n            const y = Math.min(this.selectionStartPoint.y, this.selectionEndPoint.y);\n            const width = Math.abs(this.selectionEndPoint.x - this.selectionStartPoint.x);\n            const height = Math.abs(this.selectionEndPoint.y - this.selectionStartPoint.y);\n            // Get all elements in the selection rectangle\n            const elementsInRect = this.globalManager.getElementsInRectangle(x, y, width, height);\n            // Clear and reselect elements\n            this.globalManager.clearSelection();\n            elementsInRect.forEach(element => {\n                this.globalManager.addToSelection(element.id);\n            });\n            this.render();\n            return;\n        }\n        // Only handle if we're actively dragging or resizing from this canvas\n        if (!this.dragState.isDragging && !this.resizeState.isResizing && !this.cropDragging && !this.cropResizing) {\n            // Check for hover effects\n            if (e.target === this.canvas) {\n                if (this.cropMode) {\n                    // In crop mode, only change cursor near crop handles\n                    const selectedElement = this.globalManager.getSelectedElement();\n                    if (selectedElement && selectedElement.type === 'image' && this.cropBounds) {\n                        const localX = selectedElement.x - this.offsetX;\n                        const localY = selectedElement.y - this.offsetY;\n                        const mouseX = localPoint.x - localX;\n                        const mouseY = localPoint.y - localY;\n                        const threshold = 20;\n                        const bounds = this.cropBounds;\n                        const nearLeft = Math.abs(mouseX - bounds.left) < threshold;\n                        const nearRight = Math.abs(mouseX - bounds.right) < threshold;\n                        const nearTop = Math.abs(mouseY - bounds.top) < threshold;\n                        const nearBottom = Math.abs(mouseY - bounds.bottom) < threshold;\n                        // Set cursor based on proximity to handles\n                        if (nearLeft && nearTop) {\n                            this.canvas.style.cursor = 'nw-resize';\n                        }\n                        else if (nearRight && nearTop) {\n                            this.canvas.style.cursor = 'ne-resize';\n                        }\n                        else if (nearRight && nearBottom) {\n                            this.canvas.style.cursor = 'se-resize';\n                        }\n                        else if (nearLeft && nearBottom) {\n                            this.canvas.style.cursor = 'sw-resize';\n                        }\n                        else if (nearLeft) {\n                            this.canvas.style.cursor = 'w-resize';\n                        }\n                        else if (nearRight) {\n                            this.canvas.style.cursor = 'e-resize';\n                        }\n                        else if (nearTop) {\n                            this.canvas.style.cursor = 'n-resize';\n                        }\n                        else if (nearBottom) {\n                            this.canvas.style.cursor = 's-resize';\n                        }\n                        else {\n                            this.canvas.style.cursor = 'default';\n                        }\n                    }\n                    else {\n                        this.canvas.style.cursor = 'default';\n                    }\n                }\n                else {\n                    // Normal mode - check for resize handles\n                    const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n                    const selectedElement = this.globalManager.getSelectedElement();\n                    const handle = selectedElement && element && element.id === selectedElement.id ?\n                        this.getResizeHandle(localPoint, element) : null;\n                    this.canvas.style.cursor = handle ? this.getCursorForHandle(handle) : 'default';\n                }\n            }\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const currentLocalPoint = {\n            x: (e.clientX - rect.left) / this.scale,\n            y: (e.clientY - rect.top) / this.scale\n        };\n        const currentGlobalPoint = this.localToGlobal(currentLocalPoint.x, currentLocalPoint.y);\n        if (this.resizeState.isResizing && this.resizeState.element) {\n            this.handleResize(currentGlobalPoint);\n        }\n        else if (this.dragState.isDragging && this.dragState.element) {\n            const dx = currentGlobalPoint.x - this.dragState.startPoint.x;\n            const dy = currentGlobalPoint.y - this.dragState.startPoint.y;\n            // Check if we're moving multiple selected elements\n            const selectedElements = this.globalManager.getSelectedElements();\n            if (selectedElements.length > 1) {\n                // Move all selected elements together\n                selectedElements.forEach(element => {\n                    // Calculate new position for each element\n                    const originalPos = this.originalPositions.get(element.id) || { x: element.x, y: element.y };\n                    let newX = originalPos.x + dx;\n                    let newY = originalPos.y + dy;\n                    // If linking is disabled, allow partial hiding but prevent complete loss\n                    if (!this.isLinkingEnabled()) {\n                        const minVisible = 50; // Minimum pixels that must remain visible\n                        // Ensure at least minVisible pixels remain on canvas\n                        newX = Math.max(this.offsetX - element.width + minVisible, Math.min(newX, this.offsetX + this.canvas.width - minVisible));\n                        newY = Math.max(this.offsetY - element.height + minVisible, Math.min(newY, this.offsetY + this.canvas.height - minVisible));\n                    }\n                    // Update element's global position\n                    this.globalManager.updateElement(element.id, {\n                        x: newX,\n                        y: newY\n                    });\n                });\n            }\n            else {\n                // Single element drag (original logic)\n                let newX = this.dragState.elementStartPoint.x + dx;\n                let newY = this.dragState.elementStartPoint.y + dy;\n                // If linking is disabled, allow partial hiding but prevent complete loss\n                if (!this.isLinkingEnabled()) {\n                    const element = this.dragState.element;\n                    const minVisible = 50; // Minimum pixels that must remain visible\n                    // Ensure at least minVisible pixels remain on canvas\n                    newX = Math.max(this.offsetX - element.width + minVisible, Math.min(newX, this.offsetX + this.canvas.width - minVisible));\n                    newY = Math.max(this.offsetY - element.height + minVisible, Math.min(newY, this.offsetY + this.canvas.height - minVisible));\n                }\n                // Update element's global position\n                this.globalManager.updateElement(this.dragState.element.id, {\n                    x: newX,\n                    y: newY\n                });\n                // Only emit dragging event when linking is enabled\n                if (this.isLinkingEnabled()) {\n                    document.dispatchEvent(new CustomEvent('element-dragging', {\n                        detail: {\n                            elementId: this.dragState.element.id,\n                            globalX: newX,\n                            globalY: newY\n                        }\n                    }));\n                }\n            }\n            // Trigger re-render on all canvases\n            document.dispatchEvent(new CustomEvent('element-moved'));\n        }\n        else {\n            const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            this.canvas.style.cursor = handle ? this.getCursorForHandle(handle) : 'default';\n        }\n        this.render();\n    }\n    handleElementOverflow(element) {\n        // Emit event for multi-canvas manager to handle overflow\n        const event = new CustomEvent('element-overflow', {\n            detail: {\n                element: element,\n                canvasId: this.canvas.id,\n                bounds: {\n                    left: element.x,\n                    right: element.x + element.width,\n                    top: element.y,\n                    bottom: element.y + element.height\n                }\n            }\n        });\n        document.dispatchEvent(event);\n    }\n    handleResize(point) {\n        if (!this.resizeState.element || !this.resizeState.handle)\n            return;\n        const dx = point.x - this.resizeState.startPoint.x;\n        const dy = point.y - this.resizeState.startPoint.y;\n        const original = this.resizeState.originalBounds;\n        const element = this.resizeState.element;\n        // Check if it's a corner handle for proportional resizing\n        const isCorner = ['nw', 'ne', 'se', 'sw'].includes(this.resizeState.handle);\n        let updates = {};\n        if (isCorner) {\n            // Proportional resizing for corners\n            const aspectRatio = original.width / original.height;\n            let newWidth = original.width;\n            let newHeight = original.height;\n            switch (this.resizeState.handle) {\n                case 'nw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'ne':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'se':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    break;\n                case 'sw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    break;\n            }\n            updates.width = Math.max(20, newWidth);\n            updates.height = Math.max(20, newHeight);\n            // Scale font size for text elements\n            if (element.type === 'text' && element.fontSize) {\n                const scale = newWidth / original.width;\n                updates.fontSize = this.resizeState.originalBounds.originalFontSize * scale;\n            }\n        }\n        else {\n            // Free resizing for edge handles\n            switch (this.resizeState.handle) {\n                case 'n':\n                    updates.y = original.y + dy;\n                    updates.height = original.height - dy;\n                    break;\n                case 'e':\n                    updates.width = original.width + dx;\n                    break;\n                case 's':\n                    updates.height = original.height + dy;\n                    break;\n                case 'w':\n                    updates.x = original.x + dx;\n                    updates.width = original.width - dx;\n                    break;\n            }\n            if (updates.width !== undefined)\n                updates.width = Math.max(20, updates.width);\n            if (updates.height !== undefined)\n                updates.height = Math.max(20, updates.height);\n        }\n        // Update element through global manager\n        this.globalManager.updateElement(element.id, updates);\n        // Trigger re-render on all canvases\n        document.dispatchEvent(new CustomEvent('element-moved'));\n    }\n    getCursorForHandle(handle) {\n        const cursors = {\n            'nw': 'nw-resize',\n            'n': 'n-resize',\n            'ne': 'ne-resize',\n            'e': 'e-resize',\n            'se': 'se-resize',\n            's': 's-resize',\n            'sw': 'sw-resize',\n            'w': 'w-resize'\n        };\n        return cursors[handle];\n    }\n    getResizeHandle(localPoint, element) {\n        if (!element)\n            return null;\n        // Convert element global position to local for handle calculation\n        const localPos = this.globalToLocal(element.x, element.y);\n        const handleSize = 8 / this.scale;\n        const handles = [\n            { handle: 'nw', x: localPos.x, y: localPos.y },\n            { handle: 'n', x: localPos.x + element.width / 2, y: localPos.y },\n            { handle: 'ne', x: localPos.x + element.width, y: localPos.y },\n            { handle: 'e', x: localPos.x + element.width, y: localPos.y + element.height / 2 },\n            { handle: 'se', x: localPos.x + element.width, y: localPos.y + element.height },\n            { handle: 's', x: localPos.x + element.width / 2, y: localPos.y + element.height },\n            { handle: 'sw', x: localPos.x, y: localPos.y + element.height },\n            { handle: 'w', x: localPos.x, y: localPos.y + element.height / 2 }\n        ];\n        for (const h of handles) {\n            if (Math.abs(localPoint.x - h.x) <= handleSize &&\n                Math.abs(localPoint.y - h.y) <= handleSize) {\n                return h.handle;\n            }\n        }\n        return null;\n    }\n    handleMouseUp(e) {\n        // Reset crop states\n        if (this.cropDragging || this.cropResizing || this.cropHandle) {\n            this.cropDragging = false;\n            this.cropResizing = false;\n            this.cropResizeHandle = '';\n            this.cropHandle = null; // Reset crop handle\n            this.render();\n            return;\n        }\n        // Reset selection dragging\n        if (this.isSelectionDragging) {\n            this.isSelectionDragging = false;\n            this.render();\n            return;\n        }\n        // Only reset states if this canvas was the one dragging/resizing\n        if (this.dragState.isDragging || this.resizeState.isResizing) {\n            this.dragState = {\n                isDragging: false,\n                element: null,\n                startPoint: { x: 0, y: 0 },\n                elementStartPoint: { x: 0, y: 0 }\n            };\n            this.originalPositions.clear();\n            this.resizeState = {\n                isResizing: false,\n                element: null,\n                handle: null,\n                startPoint: { x: 0, y: 0 },\n                originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n            };\n            // Re-render all canvases to ensure proper state\n            document.dispatchEvent(new CustomEvent('element-moved'));\n        }\n    }\n    handleDoubleClick(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element) {\n            if (element.type === 'text' && !this.cropMode) {\n                this.startInlineEditing(element);\n            }\n            else if (element.type === 'image') {\n                // Toggle crop mode on double-click for images\n                if (!this.cropMode) {\n                    this.globalManager.setSelectedElement(element.id);\n                    this.toggleCropMode();\n                }\n            }\n        }\n    }\n    startSimpleCropMode(element) {\n        if (element.type !== 'image')\n            return;\n        this.cropMode = true;\n        this.globalManager.setSelectedElement(element.id);\n        // Store original dimensions if not already stored\n        if (!element.originalWidth) {\n            this.globalManager.updateElement(element.id, {\n                originalWidth: element.width,\n                originalHeight: element.height,\n                originalImageElement: element.imageElement\n            });\n        }\n        // Initialize crop bounds to full image (user will drag edges inward)\n        this.cropBounds = {\n            left: 0,\n            top: 0,\n            right: element.width,\n            bottom: element.height\n        };\n        // If element has previous crop, use those bounds\n        if (element.cropX !== undefined && element.cropWidth !== undefined) {\n            this.cropBounds = {\n                left: element.cropX,\n                top: element.cropY || 0,\n                right: element.cropX + element.cropWidth,\n                bottom: (element.cropY || 0) + (element.cropHeight || 0)\n            };\n        }\n        this.cropOriginalBounds = { ...this.cropBounds };\n        // Update element with initial crop values\n        this.globalManager.updateElement(element.id, {\n            cropX: this.cropBounds.left,\n            cropY: this.cropBounds.top,\n            cropWidth: this.cropBounds.right - this.cropBounds.left,\n            cropHeight: this.cropBounds.bottom - this.cropBounds.top\n        });\n        // Show crop toolbar\n        this.showCropToolbar();\n        this.render();\n    }\n    updateCropInfo() {\n        const infoElement = document.querySelector('.crop-info');\n        if (infoElement && this.cropBounds) {\n            const width = Math.round(this.cropBounds.right - this.cropBounds.left);\n            const height = Math.round(this.cropBounds.bottom - this.cropBounds.top);\n            infoElement.textContent = `${width}  ${height}px`;\n        }\n    }\n    createInlineTextEditor(globalX, globalY, initialText, fontSize) {\n        // Check if we're already editing\n        const existingEditor = document.querySelector('.text-editor-active');\n        if (existingEditor) {\n            return; // Already editing\n        }\n        // NOTE: For NEW text, we DON'T pre-generate an ID - we'll create it when saving\n        // This avoids confusion with element lookups\n        // Convert global position to local for display\n        const localPos = this.globalToLocal(globalX, globalY);\n        // Create a contentEditable div for inline editing\n        const editor = document.createElement('div');\n        editor.className = 'text-editor-active text-editor-create'; // Add class to identify NEW text editor\n        editor.setAttribute('data-editor-type', 'create');\n        // DON'T set element ID for new text - it doesn't exist yet!\n        editor.contentEditable = 'true';\n        editor.innerText = initialText;\n        editor.style.position = 'fixed';\n        // Calculate position based on canvas position and scale\n        const rect = this.canvas.getBoundingClientRect();\n        const toolbarHeight = this.textToolbar ? this.textToolbar.offsetHeight : 0;\n        const editorTop = rect.top + localPos.y * this.scale;\n        // Check if editor would overlap with toolbar and adjust position\n        let adjustedTop = editorTop;\n        // Text toolbar is at fixed position top: 60px, so check if editor is too high\n        const textToolbarBottom = 60 + (toolbarHeight || 50); // 60px top + toolbar height\n        if (editorTop < textToolbarBottom + 10) {\n            adjustedTop = textToolbarBottom + 20; // Position below toolbar with margin\n        }\n        editor.style.left = `${rect.left + localPos.x * this.scale}px`;\n        editor.style.top = `${adjustedTop}px`;\n        editor.style.minWidth = `${100 * this.scale}px`;\n        editor.style.minHeight = `${fontSize * 1.5 * this.scale}px`;\n        editor.style.maxWidth = `${(this.canvas.width - localPos.x) * this.scale}px`;\n        // Apply text styles\n        editor.style.font = `${fontSize * this.scale}px Arial`;\n        editor.style.color = '#2d3748';\n        editor.style.textAlign = 'left';\n        // Visual styles for better visibility with semi-transparent background\n        editor.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';\n        editor.style.border = '2px solid #3182ce';\n        editor.style.borderRadius = '4px';\n        editor.style.padding = `${5 * this.scale}px`;\n        editor.style.margin = '0';\n        editor.style.zIndex = '10000';\n        editor.style.whiteSpace = 'pre-wrap';\n        editor.style.wordBreak = 'break-word';\n        editor.style.overflow = 'auto';\n        editor.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';\n        editor.style.outline = 'none';\n        editor.style.lineHeight = '1.2';\n        document.body.appendChild(editor);\n        // Select all text\n        editor.focus();\n        const range = document.createRange();\n        range.selectNodeContents(editor);\n        const selection = window.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        let isFinished = false;\n        const finishEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Generate ID only when we're actually creating the element\n            const newElementId = `element-${Date.now()}`;\n            // Get the content - remove zero-width spaces\n            let content = editor.innerText.replace(/\\u200B/g, '').trim();\n            if (!content || content.length === 0) {\n                content = ''; // Default text if empty\n            }\n            // Now create the actual element with the edited content\n            const element = {\n                id: newElementId,\n                type: 'text',\n                x: globalX,\n                y: globalY,\n                width: 200,\n                height: fontSize * 1.5,\n                content: content,\n                fontSize: fontSize,\n                fontFamily: 'Arial',\n                fontWeight: 'normal',\n                fontStyle: 'normal',\n                textAlign: 'left',\n                color: '#2d3748',\n                canvasId: this.canvas.id\n            };\n            // Add element to canvas\n            this.globalManager.addElement(element);\n            this.globalManager.setSelectedElement(element.id);\n            this.updateTextToolbar();\n            // Update dimensions\n            this.updateTextDimensions(element);\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            this.render();\n        };\n        const cancelEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Just remove editor without creating element\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n        };\n        // Track if we should handle blur\n        let shouldHandleBlur = true;\n        let isProcessingKeyboard = false;\n        // Event handlers\n        editor.addEventListener('blur', (e) => {\n            // Don't process blur if we're in the middle of keyboard processing\n            if (isProcessingKeyboard) {\n                return;\n            }\n            // Check if we're clicking on the text toolbar\n            const relatedTarget = e.relatedTarget;\n            if (relatedTarget && this.textToolbar && this.textToolbar.contains(relatedTarget)) {\n                // Refocus the editor if clicking on toolbar\n                setTimeout(() => {\n                    if (document.body.contains(editor)) {\n                        editor.focus();\n                    }\n                }, 0);\n                return;\n            }\n            // Only process blur if we should\n            if (shouldHandleBlur) {\n                // Use requestAnimationFrame to ensure all input events have completed\n                requestAnimationFrame(() => {\n                    if (!isProcessingKeyboard && document.body.contains(editor)) {\n                        finishEditing();\n                    }\n                });\n            }\n        });\n        editor.addEventListener('keydown', (e) => {\n            // Handle special keys\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                cancelEditing();\n                return;\n            }\n            // Enter to confirm (without Shift)\n            if (e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n            // Tab to confirm\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n        });\n        // Handle backspace/delete separately to prevent issues\n        editor.addEventListener('beforeinput', (e) => {\n            // If deleting and text would become empty, prevent default and handle manually\n            if ((e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward')) {\n                const currentText = editor.innerText || '';\n                const selection = window.getSelection()?.toString() || '';\n                // If we're about to delete the last character\n                if (currentText.length <= 1 || (selection === currentText)) {\n                    // Don't prevent default - let it delete, but maintain minimum content\n                    requestAnimationFrame(() => {\n                        const afterDeleteText = editor.innerText || '';\n                        if (!editor.innerText || editor.innerText.length === 0) {\n                            editor.innerHTML = '\\u200B';\n                            // Position cursor at start\n                            const range = document.createRange();\n                            const sel = window.getSelection();\n                            if (editor.firstChild) {\n                                range.setStart(editor.firstChild, 0);\n                                range.collapse(true);\n                                sel?.removeAllRanges();\n                                sel?.addRange(range);\n                            }\n                        }\n                    });\n                }\n            }\n        });\n        // Track composition state for Korean/IME input\n        let isComposing = false;\n        let lastCompositionData = '';\n        editor.addEventListener('compositionstart', (e) => {\n            isComposing = true;\n        });\n        editor.addEventListener('compositionupdate', (e) => {\n            lastCompositionData = e.data || '';\n        });\n        editor.addEventListener('compositionend', (e) => {\n            isComposing = false;\n            // Fix for Korean IME duplication in Chrome/Safari\n            // Check if the last character is duplicated\n            setTimeout(() => {\n                const text = editor.innerText;\n                if (text.length >= 2) {\n                    const lastChar = text[text.length - 1];\n                    const secondLastChar = text[text.length - 2];\n                    // If last two characters are the same and it's a Korean character\n                    if (lastChar === secondLastChar && /[---]/.test(lastChar)) {\n                        // Remove the duplicate\n                        editor.innerText = text.slice(0, -1);\n                        // Restore cursor position to end\n                        const range = document.createRange();\n                        const sel = window.getSelection();\n                        range.selectNodeContents(editor);\n                        range.collapse(false);\n                        sel?.removeAllRanges();\n                        sel?.addRange(range);\n                    }\n                }\n            }, 0);\n        });\n        // Combined input handler for resize only\n        editor.addEventListener('input', (e) => {\n            // Don't manipulate during composition\n            if (isComposing) {\n                return;\n            }\n            // Auto-resize\n            const newHeight = editor.scrollHeight;\n            if (newHeight > parseInt(editor.style.minHeight)) {\n                editor.style.height = `${newHeight}px`;\n            }\n        });\n    }\n    startInlineEditing(element) {\n        if (element.type !== 'text')\n            return;\n        // Get fresh element reference from global manager\n        const currentElement = this.globalManager.getElement(element.id);\n        if (!currentElement) {\n            return;\n        }\n        // Store element ID early for use in attributes\n        const elementId = currentElement.id;\n        // Check if we're already editing this element\n        const existingEditor = document.querySelector('.text-editor-active');\n        if (existingEditor) {\n            return; // Already editing\n        }\n        // Keep the element selected and toolbar visible during editing\n        this.globalManager.setSelectedElement(element.id);\n        this.updateTextToolbar();\n        // Create a contentEditable div for inline editing\n        const editor = document.createElement('div');\n        editor.className = 'text-editor-active text-editor-edit'; // Add class to identify EDIT text editor\n        editor.setAttribute('data-editor-type', 'edit');\n        editor.setAttribute('data-element-id', elementId);\n        editor.contentEditable = 'true';\n        editor.innerText = currentElement.content;\n        editor.style.position = 'fixed';\n        // Calculate position based on canvas position and scale\n        const rect = this.canvas.getBoundingClientRect();\n        const container = this.canvas.parentElement?.getBoundingClientRect();\n        // Convert global element position to local canvas position\n        const localPos = this.globalToLocal(element.x, element.y);\n        // Adjust for container scroll if needed\n        const scrollLeft = this.canvas.parentElement?.scrollLeft || 0;\n        const scrollTop = this.canvas.parentElement?.scrollTop || 0;\n        // Check if editor would overlap with toolbar and adjust position\n        const toolbarHeight = this.textToolbar ? this.textToolbar.offsetHeight : 0;\n        const editorTop = rect.top + (localPos.y - scrollTop) * this.scale;\n        let adjustedTop = editorTop;\n        // Text toolbar is at fixed position top: 60px, so check if editor is too high\n        const textToolbarBottom = 60 + (toolbarHeight || 50); // 60px top + toolbar height\n        if (editorTop < textToolbarBottom + 10) {\n            adjustedTop = Math.max(editorTop, textToolbarBottom + 20); // Keep below toolbar\n        }\n        editor.style.left = `${rect.left + (localPos.x - scrollLeft) * this.scale}px`;\n        editor.style.top = `${adjustedTop}px`;\n        editor.style.minWidth = `${Math.max(100, element.width) * this.scale}px`;\n        editor.style.minHeight = `${element.height * this.scale}px`;\n        editor.style.maxWidth = `${(this.canvas.width - localPos.x) * this.scale}px`;\n        // Apply text styles exactly matching canvas\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        editor.style.font = `${style}${weight}${(element.fontSize || 24) * this.scale}px ${element.fontFamily || 'Arial'}`;\n        editor.style.color = element.color || '#2d3748';\n        editor.style.textAlign = element.textAlign || 'left';\n        // Visual styles for better visibility with semi-transparent background\n        editor.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';\n        editor.style.border = '2px solid #3182ce';\n        editor.style.borderRadius = '4px';\n        editor.style.padding = `${5 * this.scale}px`;\n        editor.style.margin = '0';\n        editor.style.zIndex = '10000';\n        editor.style.whiteSpace = 'pre-wrap';\n        editor.style.wordBreak = 'break-word';\n        editor.style.overflow = 'auto';\n        editor.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';\n        editor.style.outline = 'none';\n        // Line height to match canvas rendering\n        editor.style.lineHeight = '1.2';\n        // Store original content but DON'T hide the canvas text\n        const originalContent = currentElement.content;\n        // elementId already declared above\n        // Don't set editingElementId - keep text visible\n        // this.editingElementId = elementId; // REMOVED - keep text visible\n        // this.render(); // Don't re-render to avoid flicker\n        document.body.appendChild(editor);\n        // Select all text\n        editor.focus();\n        const range = document.createRange();\n        range.selectNodeContents(editor);\n        const selection = window.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        let isFinished = false;\n        const finishEditing = () => {\n            if (isFinished) {\n                return;\n            }\n            isFinished = true;\n            // Get the current content - handle all whitespace properly\n            let rawContent = editor.innerText || editor.textContent || '';\n            // Remove zero-width spaces and normalize\n            let newContent = rawContent.replace(/\\u200B/g, '').replace(/\\u00A0/g, ' ').trim();\n            // Always ensure we have content\n            if (!newContent || newContent.length === 0) {\n                newContent = ''; // Default text if empty\n            }\n            // Get the existing element to preserve its properties\n            const existingElement = this.globalManager.getElement(elementId);\n            if (!existingElement) {\n                if (document.body.contains(editor)) {\n                    document.body.removeChild(editor);\n                }\n                return;\n            }\n            //        \n            // :  ID        \n            this.globalManager.updateElement(elementId, {\n                content: newContent\n            });\n            // Remove editor\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            // Update text dimensions for the updated element\n            const updatedElement = this.globalManager.getElement(elementId);\n            if (updatedElement) {\n                this.updateTextDimensions(updatedElement);\n                // Keep element selected and toolbar visible\n                this.globalManager.setSelectedElement(elementId);\n                this.updateTextToolbar();\n            }\n            this.render();\n        };\n        const cancelEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Don't update - just leave the original element as is\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            this.render();\n        };\n        // Track if we should handle blur and keyboard processing\n        let shouldHandleBlur = true;\n        let isProcessingKeyboard = false;\n        let finishingViaKeyboard = false;\n        // Event handlers\n        editor.addEventListener('blur', (e) => {\n            //    blur \n            if (isProcessingKeyboard) {\n                return;\n            }\n            //   \n            if (isFinished) {\n                return;\n            }\n            // Check if we're clicking on the text toolbar\n            const relatedTarget = e.relatedTarget;\n            if (relatedTarget && this.textToolbar && this.textToolbar.contains(relatedTarget)) {\n                // Refocus the editor if clicking on toolbar\n                setTimeout(() => {\n                    if (document.body.contains(editor)) {\n                        editor.focus();\n                    }\n                }, 0);\n                return;\n            }\n            //  finishEditing  ( )\n            finishEditing();\n        });\n        editor.addEventListener('keydown', (e) => {\n            // Handle special keys\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                cancelEditing();\n                return;\n            }\n            // Enter to confirm (without Shift)\n            if (e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                finishingViaKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n            // Tab to confirm\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                finishingViaKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n        });\n        // Handle backspace/delete separately to prevent issues\n        editor.addEventListener('beforeinput', (e) => {\n            // If deleting and text would become empty, prevent default and handle manually\n            if ((e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward')) {\n                const currentText = editor.innerText || '';\n                const selection = window.getSelection()?.toString() || '';\n                // If we're about to delete the last character\n                if (currentText.length <= 1 || (selection === currentText)) {\n                    // Don't prevent default - let it delete, but maintain minimum content\n                    requestAnimationFrame(() => {\n                        const afterDeleteText = editor.innerText || '';\n                        if (!editor.innerText || editor.innerText.length === 0) {\n                            editor.innerHTML = '\\u200B';\n                            // Position cursor at start\n                            const range = document.createRange();\n                            const sel = window.getSelection();\n                            if (editor.firstChild) {\n                                range.setStart(editor.firstChild, 0);\n                                range.collapse(true);\n                                sel?.removeAllRanges();\n                                sel?.addRange(range);\n                            }\n                        }\n                    });\n                }\n            }\n        });\n        // Keep toolbar visible during editing\n        editor.addEventListener('focus', () => {\n            this.globalManager.setSelectedElement(elementId);\n            this.updateTextToolbar();\n        });\n        // Track composition state for Korean/IME input\n        let isComposing = false;\n        let lastCompositionData = '';\n        editor.addEventListener('compositionstart', (e) => {\n            isComposing = true;\n        });\n        editor.addEventListener('compositionupdate', (e) => {\n            lastCompositionData = e.data || '';\n        });\n        editor.addEventListener('compositionend', (e) => {\n            isComposing = false;\n            // Fix for Korean IME duplication in Chrome/Safari\n            // Check if the last character is duplicated\n            setTimeout(() => {\n                const text = editor.innerText;\n                if (text.length >= 2) {\n                    const lastChar = text[text.length - 1];\n                    const secondLastChar = text[text.length - 2];\n                    // If last two characters are the same and it's a Korean character\n                    if (lastChar === secondLastChar && /[---]/.test(lastChar)) {\n                        // Remove the duplicate\n                        editor.innerText = text.slice(0, -1);\n                        // Restore cursor position to end\n                        const range = document.createRange();\n                        const sel = window.getSelection();\n                        range.selectNodeContents(editor);\n                        range.collapse(false);\n                        sel?.removeAllRanges();\n                        sel?.addRange(range);\n                    }\n                }\n            }, 0);\n        });\n        // Combined input handler for resize only\n        editor.addEventListener('input', (e) => {\n            // Don't manipulate during composition\n            if (isComposing) {\n                return;\n            }\n            // Auto-resize\n            const newHeight = editor.scrollHeight;\n            if (newHeight > parseInt(editor.style.minHeight)) {\n                editor.style.height = `${newHeight}px`;\n            }\n        });\n        // Update position if canvas scrolls\n        const updatePosition = () => {\n            const rect = this.canvas.getBoundingClientRect();\n            const localPos = this.globalToLocal(currentElement.x, currentElement.y);\n            editor.style.left = `${rect.left + localPos.x * this.scale}px`;\n            editor.style.top = `${rect.top + localPos.y * this.scale}px`;\n        };\n        window.addEventListener('scroll', updatePosition);\n        window.addEventListener('resize', updatePosition);\n        // Clean up scroll listeners when done\n        const originalFinish = finishEditing;\n        const cleanup = () => {\n            window.removeEventListener('scroll', updatePosition);\n            window.removeEventListener('resize', updatePosition);\n        };\n        editor.addEventListener('blur', cleanup);\n    }\n    updateTextDimensions(element) {\n        if (element.type !== 'text')\n            return;\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize || 24}px ${element.fontFamily || 'Arial'}`;\n        // Handle multi-line text\n        const lines = element.content.split('\\n');\n        const lineHeight = (element.fontSize || 24) * 1.2;\n        // Calculate max width from all lines\n        let maxWidth = 0;\n        lines.forEach(line => {\n            const metrics = this.ctx.measureText(line);\n            maxWidth = Math.max(maxWidth, metrics.width);\n        });\n        this.globalManager.updateElement(element.id, {\n            width: maxWidth + 10,\n            height: lineHeight * lines.length\n        });\n        this.ctx.restore();\n    }\n    getMousePosition(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / this.scale;\n        const y = (e.clientY - rect.top) / this.scale;\n        return { x, y };\n    }\n    getElementAtPoint(localPoint) {\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        return this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n    }\n    addText(text = '') {\n        const baseFontSize = 24;\n        // Convert local center position to global position\n        const localCenter = {\n            x: this.canvas.width / 2 - 50,\n            y: this.canvas.height / 2 - baseFontSize / 2\n        };\n        const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n        // Create editor directly without adding element first\n        this.createInlineTextEditor(globalPos.x, globalPos.y, text, baseFontSize);\n    }\n    addImage(imageUrl) {\n        const img = new Image();\n        img.onload = () => {\n            const maxSize = 300;\n            let width = img.width;\n            let height = img.height;\n            if (width > maxSize || height > maxSize) {\n                const ratio = Math.min(maxSize / width, maxSize / height);\n                width *= ratio;\n                height *= ratio;\n            }\n            // Convert local center position to global position\n            const localCenter = {\n                x: this.canvas.width / 2 - width / 2,\n                y: this.canvas.height / 2 - height / 2\n            };\n            const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n            const element = {\n                id: `element-${Date.now()}`,\n                type: 'image',\n                x: globalPos.x, // Global position\n                y: globalPos.y,\n                width: width,\n                height: height,\n                content: imageUrl,\n                imageElement: img,\n                canvasId: this.canvas.id\n            };\n            this.globalManager.addElement(element);\n            this.globalManager.setSelectedElement(element.id);\n            this.render();\n        };\n        img.src = imageUrl;\n    }\n    clear() {\n        // Clear all elements from global manager\n        this.globalManager.clearAll();\n        this.updateTextToolbar();\n        this.render();\n    }\n    startCropMode() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement && selectedElement.type === 'image') {\n            // Only start crop if not already in crop mode\n            if (!this.cropMode) {\n                this.toggleCropMode();\n            }\n        }\n    }\n    deleteSelected() {\n        // Delete all selected elements (supports multi-selection)\n        const selectedElements = this.globalManager.getSelectedElements();\n        if (selectedElements.length > 0) {\n            selectedElements.forEach(element => {\n                this.globalManager.removeElement(element.id);\n            });\n            this.globalManager.clearSelection();\n            this.updateTextToolbar();\n            this.render();\n        }\n        else {\n            // Fallback to single selection\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement) {\n                this.globalManager.removeElement(selectedElement.id);\n                this.updateTextToolbar();\n                this.render();\n            }\n        }\n    }\n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Get all elements that should be visible on this canvas\n        const visibleElements = this.globalManager.getElementsForCanvas(this.offsetX, this.offsetY, this.canvas.width, this.canvas.height);\n        // Render each visible element\n        for (const element of visibleElements) {\n            // If linking is disabled, only render elements that belong to this canvas\n            // or elements being dragged (to allow partial visibility)\n            if (!this.isLinkingEnabled() && element.canvasId !== this.canvas.id) {\n                // Skip elements from other canvases unless they're being dragged\n                if (!this.dragState.isDragging || this.dragState.element?.id !== element.id) {\n                    continue;\n                }\n            }\n            this.ctx.save();\n            // Convert element's global position to local position for rendering\n            const localPos = this.globalToLocal(element.x, element.y);\n            const localElement = { ...element, x: localPos.x, y: localPos.y };\n            if (element.type === 'text') {\n                this.renderText(localElement);\n            }\n            else if (element.type === 'image' && element.imageElement) {\n                this.renderImage(localElement);\n            }\n            // Render selection if this element is selected (either single or multi-selection)\n            if (this.globalManager.isSelected(element.id)) {\n                this.renderSelection(localElement);\n                // Only render resize handles for single selection AND not in crop mode\n                const selectedElements = this.globalManager.getSelectedElements();\n                if (!this.cropMode && (selectedElements.length === 1 ||\n                    (this.globalManager.getSelectedElement()?.id === element.id))) {\n                    this.renderResizeHandles(localElement);\n                }\n            }\n            this.ctx.restore();\n        }\n        // Render selection rectangle if dragging\n        if (this.isSelectionDragging) {\n            this.renderSelectionRectangle();\n        }\n    }\n    renderSelectionRectangle() {\n        const localStart = this.globalToLocal(this.selectionStartPoint.x, this.selectionStartPoint.y);\n        const localEnd = this.globalToLocal(this.selectionEndPoint.x, this.selectionEndPoint.y);\n        const x = Math.min(localStart.x, localEnd.x);\n        const y = Math.min(localStart.y, localEnd.y);\n        const width = Math.abs(localEnd.x - localStart.x);\n        const height = Math.abs(localEnd.y - localStart.y);\n        this.ctx.save();\n        this.ctx.strokeStyle = '#0066ff';\n        this.ctx.lineWidth = 1;\n        this.ctx.setLineDash([4, 4]);\n        this.ctx.strokeRect(x, y, width, height);\n        // Draw a semi-transparent fill\n        this.ctx.fillStyle = 'rgba(0, 102, 255, 0.1)';\n        this.ctx.fillRect(x, y, width, height);\n        this.ctx.restore();\n    }\n    renderText(element) {\n        // Don't skip rendering - always show text even during editing\n        // This allows the text to remain visible behind the edit overlay\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize}px ${element.fontFamily}`;\n        this.ctx.fillStyle = element.color || '#000000';\n        // Handle multi-line text\n        const lines = element.content.split('\\n');\n        const lineHeight = (element.fontSize || 24) * 1.2;\n        // Calculate total width and height\n        let maxWidth = 0;\n        lines.forEach(line => {\n            const metrics = this.ctx.measureText(line);\n            maxWidth = Math.max(maxWidth, metrics.width);\n        });\n        element.width = maxWidth + 10; // Reduced padding\n        element.height = lineHeight * lines.length;\n        // Render each line - allow rendering outside canvas bounds\n        lines.forEach((line, index) => {\n            let textX = element.x + 5;\n            if (element.textAlign === 'center') {\n                textX = element.x + element.width / 2;\n                this.ctx.textAlign = 'center';\n            }\n            else if (element.textAlign === 'right') {\n                textX = element.x + element.width - 5;\n                this.ctx.textAlign = 'right';\n            }\n            else {\n                this.ctx.textAlign = 'left';\n            }\n            const textY = element.y + lineHeight * (index + 0.5);\n            this.ctx.textBaseline = 'middle';\n            // Draw text even if it goes outside canvas bounds\n            this.ctx.fillText(line, textX, textY);\n        });\n        this.ctx.restore();\n    }\n    renderImage(element) {\n        if (element.imageElement) {\n            const selected = this.globalManager.getSelectedElement();\n            const isBeingCropped = this.cropMode && selected?.id === element.id;\n            // In crop mode, always show the full image; otherwise show cropped if crop is applied\n            if (!isBeingCropped && element.cropX !== undefined && element.cropY !== undefined &&\n                element.cropWidth !== undefined && element.cropHeight !== undefined) {\n                // Apply clipping mask to show only cropped area\n                this.ctx.save();\n                // Create clipping rectangle for the cropped area\n                this.ctx.beginPath();\n                this.ctx.rect(element.x + element.cropX, element.y + element.cropY, element.cropWidth, element.cropHeight);\n                this.ctx.clip();\n                // Draw the full image (but only cropped area will be visible due to clipping)\n                this.ctx.drawImage(element.imageElement, element.x, element.y, element.width, element.height);\n                this.ctx.restore();\n            }\n            else {\n                // Render full image (always in crop mode, or when no crop is set)\n                this.ctx.drawImage(element.imageElement, element.x, element.y, element.width, element.height);\n            }\n            // Render crop overlay if in crop mode\n            if (isBeingCropped) {\n                this.renderCropOverlay(element);\n            }\n        }\n    }\n    renderCropOverlay(element) {\n        if (!this.cropMode || element.type !== 'image' || !this.cropBounds) {\n            return;\n        }\n        const localX = element.x - this.offsetX;\n        const localY = element.y - this.offsetY;\n        // Save context state\n        this.ctx.save();\n        // Draw dark overlay outside crop area\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        // Draw overlay in four parts around crop area\n        const cropX = this.cropBounds.left;\n        const cropY = this.cropBounds.top;\n        const cropWidth = this.cropBounds.right - this.cropBounds.left;\n        const cropHeight = this.cropBounds.bottom - this.cropBounds.top;\n        // Top overlay\n        this.ctx.fillRect(localX, localY, element.width, cropY);\n        // Bottom overlay  \n        this.ctx.fillRect(localX, localY + cropY + cropHeight, element.width, element.height - cropY - cropHeight);\n        // Left overlay\n        this.ctx.fillRect(localX, localY + cropY, cropX, cropHeight);\n        // Right overlay\n        this.ctx.fillRect(localX + cropX + cropWidth, localY + cropY, element.width - cropX - cropWidth, cropHeight);\n        // Draw crop area border with white solid line\n        this.ctx.strokeStyle = '#ffffff';\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(localX + cropX, localY + cropY, cropWidth, cropHeight);\n        // Draw rule of thirds grid\n        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n        this.ctx.lineWidth = 1;\n        // Vertical lines\n        for (let i = 1; i <= 2; i++) {\n            const x = localX + cropX + (cropWidth * i / 3);\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, localY + cropY);\n            this.ctx.lineTo(x, localY + cropY + cropHeight);\n            this.ctx.stroke();\n        }\n        // Horizontal lines\n        for (let i = 1; i <= 2; i++) {\n            const y = localY + cropY + (cropHeight * i / 3);\n            this.ctx.beginPath();\n            this.ctx.moveTo(localX + cropX, y);\n            this.ctx.lineTo(localX + cropX + cropWidth, y);\n            this.ctx.stroke();\n        }\n        // Draw crop handles on edges and corners\n        this.drawCropHandles(localX + cropX, localY + cropY, cropWidth, cropHeight);\n        // Draw crop dimensions\n        const cropText = `${Math.round(cropWidth)}  ${Math.round(cropHeight)}px`;\n        this.ctx.font = 'bold 12px Arial';\n        const textMetrics = this.ctx.measureText(cropText);\n        const padding = 6;\n        const textX = localX + cropX + cropWidth / 2;\n        const textY = localY + cropY + cropHeight + 25;\n        // Background for text\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(textX - textMetrics.width / 2 - padding, textY - 12, textMetrics.width + padding * 2, 18);\n        // Text\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.textAlign = 'center';\n        this.ctx.fillText(cropText, textX, textY);\n        this.ctx.textAlign = 'start';\n        // Restore context state\n        this.ctx.restore();\n    }\n    drawCropHandles(x, y, width, height) {\n        // Draw clear edge bars for crop mode\n        const edgeThickness = 6; // Thick bars for edges\n        const edgeLength = 50; // Length of edge handles\n        const cornerSize = 25; // Size of corner L-shapes\n        const cornerThickness = 4; // Thickness of corner lines\n        // Corner L-shapes (like cropperjs)\n        this.ctx.strokeStyle = '#39f';\n        this.ctx.lineWidth = cornerThickness;\n        // Top-left corner\n        this.ctx.beginPath();\n        this.ctx.moveTo(x, y + cornerSize);\n        this.ctx.lineTo(x, y);\n        this.ctx.lineTo(x + cornerSize, y);\n        this.ctx.stroke();\n        // Top-right corner\n        this.ctx.beginPath();\n        this.ctx.moveTo(x + width - cornerSize, y);\n        this.ctx.lineTo(x + width, y);\n        this.ctx.lineTo(x + width, y + cornerSize);\n        this.ctx.stroke();\n        // Bottom-right corner\n        this.ctx.beginPath();\n        this.ctx.moveTo(x + width, y + height - cornerSize);\n        this.ctx.lineTo(x + width, y + height);\n        this.ctx.lineTo(x + width - cornerSize, y + height);\n        this.ctx.stroke();\n        // Bottom-left corner\n        this.ctx.beginPath();\n        this.ctx.moveTo(x + cornerSize, y + height);\n        this.ctx.lineTo(x, y + height);\n        this.ctx.lineTo(x, y + height - cornerSize);\n        this.ctx.stroke();\n        // Edge handles - thick bars in the middle of each edge\n        this.ctx.fillStyle = '#39f';\n        // Top edge bar\n        this.ctx.fillRect(x + width / 2 - edgeLength / 2, y - edgeThickness / 2, edgeLength, edgeThickness);\n        this.ctx.strokeStyle = '#fff';\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(x + width / 2 - edgeLength / 2, y - edgeThickness / 2, edgeLength, edgeThickness);\n        // Right edge bar\n        this.ctx.fillStyle = '#39f';\n        this.ctx.fillRect(x + width - edgeThickness / 2, y + height / 2 - edgeLength / 2, edgeThickness, edgeLength);\n        this.ctx.strokeRect(x + width - edgeThickness / 2, y + height / 2 - edgeLength / 2, edgeThickness, edgeLength);\n        // Bottom edge bar\n        this.ctx.fillStyle = '#39f';\n        this.ctx.fillRect(x + width / 2 - edgeLength / 2, y + height - edgeThickness / 2, edgeLength, edgeThickness);\n        this.ctx.strokeRect(x + width / 2 - edgeLength / 2, y + height - edgeThickness / 2, edgeLength, edgeThickness);\n        // Left edge bar\n        this.ctx.fillStyle = '#39f';\n        this.ctx.fillRect(x - edgeThickness / 2, y + height / 2 - edgeLength / 2, edgeThickness, edgeLength);\n        this.ctx.strokeRect(x - edgeThickness / 2, y + height / 2 - edgeLength / 2, edgeThickness, edgeLength);\n    }\n    renderSelection(element) {\n        // Different selection style for crop mode\n        if (this.cropMode) {\n            this.ctx.strokeStyle = '#39f';\n            this.ctx.lineWidth = 1;\n            this.ctx.setLineDash([]);\n            this.ctx.strokeRect(element.x - 1, element.y - 1, element.width + 2, element.height + 2);\n        }\n        else {\n            // For cropped images, show selection only around visible area\n            if (element.cropX !== undefined && element.cropY !== undefined &&\n                element.cropWidth !== undefined && element.cropHeight !== undefined) {\n                this.ctx.strokeStyle = '#3182ce';\n                this.ctx.lineWidth = 2;\n                this.ctx.setLineDash([5, 5]);\n                this.ctx.strokeRect(element.x + element.cropX, element.y + element.cropY, element.cropWidth, element.cropHeight);\n                this.ctx.setLineDash([]);\n            }\n            else {\n                // Normal selection for uncropped elements\n                this.ctx.strokeStyle = '#3182ce';\n                this.ctx.lineWidth = 2;\n                this.ctx.setLineDash([5, 5]);\n                this.ctx.strokeRect(element.x, element.y, element.width, element.height);\n                this.ctx.setLineDash([]);\n            }\n        }\n    }\n    renderResizeHandles(element) {\n        // Adjust handles for cropped images\n        let x = element.x;\n        let y = element.y;\n        let width = element.width;\n        let height = element.height;\n        if (element.cropX !== undefined && element.cropY !== undefined &&\n            element.cropWidth !== undefined && element.cropHeight !== undefined) {\n            // Use cropped area for handles\n            x = element.x + element.cropX;\n            y = element.y + element.cropY;\n            width = element.cropWidth;\n            height = element.cropHeight;\n        }\n        const handles = [\n            { x: x, y: y },\n            { x: x + width / 2, y: y },\n            { x: x + width, y: y },\n            { x: x + width, y: y + height / 2 },\n            { x: x + width, y: y + height },\n            { x: x + width / 2, y: y + height },\n            { x: x, y: y + height },\n            { x: x, y: y + height / 2 }\n        ];\n        this.ctx.fillStyle = '#3182ce';\n        this.ctx.strokeStyle = 'white';\n        this.ctx.lineWidth = 1;\n        handles.forEach(handle => {\n            this.ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);\n            this.ctx.strokeRect(handle.x - 4, handle.y - 4, 8, 8);\n        });\n    }\n    setupContextMenu() {\n        // Handle menu item clicks using event delegation\n        this.contextMenu.addEventListener('click', (e) => {\n            const target = e.target;\n            const menuItem = target.closest('.context-menu-item');\n            if (!menuItem || menuItem.classList.contains('has-submenu')) {\n                return;\n            }\n            e.stopPropagation();\n            const action = menuItem.dataset.action;\n            switch (action) {\n                case 'bring-front':\n                    this.bringToFront();\n                    break;\n                case 'bring-forward':\n                    this.bringForward();\n                    break;\n                case 'send-backward':\n                    this.sendBackward();\n                    break;\n                case 'send-back':\n                    this.sendToBack();\n                    break;\n                case 'duplicate':\n                    this.duplicateElement();\n                    break;\n                case 'copy':\n                    this.copyElement();\n                    break;\n                case 'paste':\n                    this.pasteElement();\n                    break;\n                case 'delete':\n                    this.deleteSelected();\n                    break;\n                case 'crop':\n                    this.toggleCropMode();\n                    break;\n                case 'apply-crop':\n                    this.applyCrop();\n                    break;\n            }\n            this.contextMenu.style.display = 'none';\n            this.render();\n        });\n        // Prevent context menu from closing when hovering over submenu\n        this.contextMenu.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        });\n    }\n    handleContextMenu(e) {\n        e.preventDefault();\n        // Disable context menu in crop mode\n        if (this.cropMode) {\n            return;\n        }\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        // Store click position for paste (in global coordinates)\n        this.lastContextMenuPosition = globalPoint;\n        if (element) {\n            // Show full menu for elements\n            this.globalManager.setSelectedElement(element.id);\n            this.updateTextToolbar();\n            // Show all menu items, but hide crop if not an image\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                const action = item.dataset.action;\n                if (action === 'crop' && element.type !== 'image') {\n                    item.style.display = 'none';\n                }\n                else {\n                    item.style.display = '';\n                }\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = '';\n            });\n        }\n        else {\n            // Show limited menu for empty space (only paste)\n            this.globalManager.setSelectedElement(null);\n            this.updateTextToolbar();\n            // Hide all items except paste\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                const action = item.dataset.action;\n                if (action === 'paste' && this.clipboard) {\n                    item.style.display = '';\n                }\n                else {\n                    item.style.display = 'none';\n                }\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = 'none';\n            });\n        }\n        // Position context menu exactly at mouse cursor\n        this.contextMenu.style.left = `${e.clientX}px`;\n        this.contextMenu.style.top = `${e.clientY}px`;\n        this.contextMenu.style.display = 'block';\n        // Ensure menu stays within viewport\n        requestAnimationFrame(() => {\n            const menuRect = this.contextMenu.getBoundingClientRect();\n            let adjustedX = e.clientX;\n            let adjustedY = e.clientY;\n            // Adjust horizontal position if menu goes off right edge\n            if (menuRect.right > window.innerWidth) {\n                adjustedX = Math.max(0, window.innerWidth - menuRect.width - 5);\n            }\n            // Adjust vertical position if menu goes off bottom edge\n            if (menuRect.bottom > window.innerHeight) {\n                adjustedY = Math.max(0, window.innerHeight - menuRect.height - 5);\n            }\n            if (adjustedX !== e.clientX || adjustedY !== e.clientY) {\n                this.contextMenu.style.left = `${adjustedX}px`;\n                this.contextMenu.style.top = `${adjustedY}px`;\n            }\n        });\n        this.render();\n    }\n    bringToFront() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    bringForward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to front (can be improved with layer ordering)\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    sendBackward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to back (can be improved with layer ordering)\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    sendToBack() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    copyElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            this.clipboard = { ...selectedElement };\n        }\n    }\n    pasteElement() {\n        if (this.clipboard) {\n            const newElement = {\n                ...this.clipboard,\n                id: `element-${Date.now()}`,\n                x: this.lastContextMenuPosition.x || this.clipboard.x + 20,\n                y: this.lastContextMenuPosition.y || this.clipboard.y + 20,\n                canvasId: this.canvas.id\n            };\n            // If it's an image, clone the image element\n            if (newElement.type === 'image' && this.clipboard.imageElement) {\n                const img = new Image();\n                img.src = this.clipboard.imageElement.src;\n                newElement.imageElement = img;\n            }\n            this.globalManager.addElement(newElement);\n            this.globalManager.setSelectedElement(newElement.id);\n            this.updateTextToolbar();\n        }\n    }\n    duplicateElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            const duplicate = this.globalManager.duplicateElement(selectedElement.id, 20, 20);\n            if (duplicate) {\n                this.globalManager.setSelectedElement(duplicate.id);\n                this.updateTextToolbar();\n            }\n        }\n    }\n    toggleCropMode() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement || selectedElement.type !== 'image') {\n            return;\n        }\n        this.cropMode = !this.cropMode;\n        this.cropDragging = false;\n        this.cropResizing = false;\n        if (this.cropMode) {\n            // Store original dimensions if not already stored\n            if (!selectedElement.originalWidth) {\n                this.globalManager.updateElement(selectedElement.id, {\n                    originalWidth: selectedElement.width,\n                    originalHeight: selectedElement.height\n                });\n            }\n            // Load existing crop bounds if available, otherwise use full image\n            if (selectedElement.cropX !== undefined && selectedElement.cropY !== undefined &&\n                selectedElement.cropWidth !== undefined && selectedElement.cropHeight !== undefined) {\n                // Restore previous crop settings for fine-tuning\n                this.cropBounds = {\n                    left: selectedElement.cropX,\n                    top: selectedElement.cropY,\n                    right: selectedElement.cropX + selectedElement.cropWidth,\n                    bottom: selectedElement.cropY + selectedElement.cropHeight\n                };\n            }\n            else {\n                // Initialize crop bounds to full image\n                this.cropBounds = {\n                    left: 0,\n                    top: 0,\n                    right: selectedElement.width,\n                    bottom: selectedElement.height\n                };\n            }\n            // Add crop mode class to canvas for styling\n            this.canvas.classList.add('crop-mode');\n            // Show crop toolbar\n            this.showCropToolbar();\n        }\n        else {\n            // Remove crop mode class\n            this.canvas.classList.remove('crop-mode');\n            // Hide crop toolbar\n            this.hideCropToolbar();\n        }\n        this.render();\n    }\n    showCropToolbar() {\n        // Remove existing toolbar if any\n        this.hideCropToolbar();\n        const toolbar = document.createElement('div');\n        toolbar.className = 'crop-mode-toolbar';\n        toolbar.id = 'cropToolbar';\n        const applyBtn = document.createElement('button');\n        applyBtn.className = 'apply-crop';\n        applyBtn.textContent = ' ';\n        applyBtn.onclick = () => this.applyCrop();\n        const cancelBtn = document.createElement('button');\n        cancelBtn.className = 'cancel-crop';\n        cancelBtn.textContent = ' ';\n        cancelBtn.onclick = () => {\n            this.cropMode = false;\n            this.canvas.classList.remove('crop-mode');\n            this.hideCropToolbar();\n            this.render();\n        };\n        const infoSpan = document.createElement('span');\n        infoSpan.className = 'crop-info';\n        infoSpan.textContent = '  ';\n        toolbar.appendChild(applyBtn);\n        toolbar.appendChild(infoSpan);\n        toolbar.appendChild(cancelBtn);\n        document.body.appendChild(toolbar);\n    }\n    hideCropToolbar() {\n        const toolbar = document.getElementById('cropToolbar');\n        if (toolbar) {\n            toolbar.remove();\n        }\n    }\n    applyCrop() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement || selectedElement.type !== 'image' || !this.cropMode || !this.cropBounds) {\n            return;\n        }\n        const cropX = this.cropBounds.left;\n        const cropY = this.cropBounds.top;\n        const cropWidth = this.cropBounds.right - this.cropBounds.left;\n        const cropHeight = this.cropBounds.bottom - this.cropBounds.top;\n        // Store crop bounds to mask the image (hide areas outside crop)\n        if (cropWidth > 0 && cropHeight > 0 && selectedElement.imageElement) {\n            // Just save the crop bounds - image stays same size, but only shows cropped area\n            this.globalManager.updateElement(selectedElement.id, {\n                cropX: cropX,\n                cropY: cropY,\n                cropWidth: cropWidth,\n                cropHeight: cropHeight\n                // Keep original width and height - don't change image size\n            });\n            // Exit crop mode\n            this.cropMode = false;\n            this.cropBounds = null;\n            this.cropHandle = null;\n            this.canvas.classList.remove('crop-mode');\n            this.hideCropToolbar();\n            this.render();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/CanvasManager.ts?\n}");

/***/ }),

/***/ "./src/GlobalElementManager.ts":
/*!*************************************!*\
  !*** ./src/GlobalElementManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalElementManager: () => (/* binding */ GlobalElementManager)\n/* harmony export */ });\nclass GlobalElementManager {\n    constructor() {\n        this.elements = new Map();\n        this.selectedElementId = null;\n        this.selectedElementIds = new Set(); // For multi-selection\n        this.changeListeners = new Set();\n        console.log('[GLOBAL] GlobalElementManager initialized');\n    }\n    addElement(element) {\n        console.log(`[GLOBAL] Adding element ${element.id} at global position (${element.x}, ${element.y})`);\n        this.elements.set(element.id, element);\n        this.notifyChange();\n    }\n    // Subscribe to element changes\n    subscribe(callback) {\n        this.changeListeners.add(callback);\n    }\n    // Unsubscribe from element changes\n    unsubscribe(callback) {\n        this.changeListeners.delete(callback);\n    }\n    // Notify all subscribers of changes\n    notifyChange() {\n        console.log(`[GLOBAL] Notifying ${this.changeListeners.size} subscribers of change`);\n        this.changeListeners.forEach(callback => callback());\n        // Also notify sync manager if it exists\n        const syncManager = window.canvasSyncManager;\n        if (syncManager) {\n            syncManager.notifyCanvasUpdate();\n        }\n    }\n    removeElement(elementId) {\n        if (this.elements.delete(elementId)) {\n            if (this.selectedElementId === elementId) {\n                this.selectedElementId = null;\n            }\n            this.notifyChange();\n        }\n    }\n    getElement(elementId) {\n        return this.elements.get(elementId);\n    }\n    getAllElements() {\n        return Array.from(this.elements.values());\n    }\n    updateElement(elementId, updates) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            Object.assign(element, updates);\n            this.notifyChange();\n        }\n    }\n    getElementsForCanvas(canvasOffsetX, canvasOffsetY, canvasWidth, canvasHeight) {\n        // Return ALL elements when sync is enabled (handled by CanvasSyncManager)\n        // Individual canvas will decide what to render based on sync state\n        const visibleElements = [];\n        this.elements.forEach(element => {\n            // Check if element intersects with this canvas\n            const elementRight = element.x + element.width;\n            const elementBottom = element.y + element.height;\n            const canvasRight = canvasOffsetX + canvasWidth;\n            const canvasBottom = canvasOffsetY + canvasHeight;\n            // Simple intersection check without verbose logging\n            // Check for intersection\n            if (element.x < canvasRight &&\n                elementRight > canvasOffsetX &&\n                element.y < canvasBottom &&\n                elementBottom > canvasOffsetY) {\n                visibleElements.push(element);\n            }\n        });\n        return visibleElements;\n    }\n    setSelectedElement(elementId) {\n        this.selectedElementId = elementId;\n    }\n    getSelectedElement() {\n        if (this.selectedElementId) {\n            return this.elements.get(this.selectedElementId) || null;\n        }\n        return null;\n    }\n    // Multi-selection methods\n    addToSelection(elementId) {\n        this.selectedElementIds.add(elementId);\n        this.notifyChange();\n    }\n    removeFromSelection(elementId) {\n        this.selectedElementIds.delete(elementId);\n        this.notifyChange();\n    }\n    clearSelection() {\n        this.selectedElementIds.clear();\n        this.selectedElementId = null;\n        this.notifyChange();\n    }\n    getSelectedElements() {\n        return Array.from(this.selectedElementIds)\n            .map(id => this.elements.get(id))\n            .filter(el => el !== undefined);\n    }\n    isSelected(elementId) {\n        return this.selectedElementIds.has(elementId) || this.selectedElementId === elementId;\n    }\n    getElementsInRectangle(x, y, width, height) {\n        const result = [];\n        const rectRight = x + width;\n        const rectBottom = y + height;\n        this.elements.forEach(element => {\n            const elementRight = element.x + element.width;\n            const elementBottom = element.y + element.height;\n            // Check if element intersects with selection rectangle\n            if (!(element.x > rectRight ||\n                elementRight < x ||\n                element.y > rectBottom ||\n                elementBottom < y)) {\n                result.push(element);\n            }\n        });\n        return result;\n    }\n    clearAll() {\n        this.elements.clear();\n        this.selectedElementId = null;\n    }\n    duplicateElement(elementId, offsetX = 20, offsetY = 20) {\n        const original = this.elements.get(elementId);\n        if (!original)\n            return null;\n        const duplicate = {\n            ...original,\n            id: `element-${Date.now()}`,\n            x: original.x + offsetX,\n            y: original.y + offsetY\n        };\n        // Clone image element if needed\n        if (duplicate.type === 'image' && original.imageElement) {\n            const img = new Image();\n            img.src = original.imageElement.src;\n            duplicate.imageElement = img;\n        }\n        this.addElement(duplicate);\n        return duplicate;\n    }\n    getElementAtPoint(globalX, globalY) {\n        // Iterate in reverse to get topmost element\n        const elementsArray = Array.from(this.elements.values());\n        for (let i = elementsArray.length - 1; i >= 0; i--) {\n            const element = elementsArray[i];\n            // If element has crop, check if click is within cropped area\n            if (element.cropX !== undefined && element.cropY !== undefined &&\n                element.cropWidth !== undefined && element.cropHeight !== undefined) {\n                // Check cropped area bounds\n                const cropLeft = element.x + element.cropX;\n                const cropTop = element.y + element.cropY;\n                const cropRight = cropLeft + element.cropWidth;\n                const cropBottom = cropTop + element.cropHeight;\n                if (globalX >= cropLeft && globalX <= cropRight &&\n                    globalY >= cropTop && globalY <= cropBottom) {\n                    return element;\n                }\n            }\n            else {\n                // No crop - check normal bounds\n                if (globalX >= element.x &&\n                    globalX <= element.x + element.width &&\n                    globalY >= element.y &&\n                    globalY <= element.y + element.height) {\n                    return element;\n                }\n            }\n        }\n        return null;\n    }\n    moveElementToFront(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            this.elements.delete(elementId);\n            this.elements.set(elementId, element);\n        }\n    }\n    moveElementToBack(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            const allElements = Array.from(this.elements.entries());\n            this.elements.clear();\n            this.elements.set(elementId, element);\n            allElements.forEach(([id, el]) => {\n                if (id !== elementId) {\n                    this.elements.set(id, el);\n                }\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/GlobalElementManager.ts?\n}");

/***/ }),

/***/ "./src/MultiCanvasManager.ts":
/*!***********************************!*\
  !*** ./src/MultiCanvasManager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiCanvasManager: () => (/* binding */ MultiCanvasManager)\n/* harmony export */ });\n/* harmony import */ var _CanvasManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasManager */ \"./src/CanvasManager.ts\");\n/* harmony import */ var _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalElementManager */ \"./src/GlobalElementManager.ts\");\n/* harmony import */ var _CanvasGridManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasGridManager */ \"./src/CanvasGridManager.ts\");\n\n\n\nclass MultiCanvasManager {\n    constructor() {\n        this.canvases = new Map();\n        this.canvasDataMap = new Map();\n        this.activeCanvasId = null;\n        this.canvasCount = 0;\n        this.totalWidth = 0; // Track total width of all canvases\n        this.currentResolution = { width: 800, height: 600 };\n        this.currentZoom = 1;\n        this.viewOffset = { x: 0, y: 0 };\n        this.viewportWidth = window.innerWidth;\n        this.viewportHeight = window.innerHeight;\n        this.virtualCanvas = { width: 5000, height: 5000 }; // Virtual infinite canvas\n        this.globalElementManager = new _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__.GlobalElementManager();\n        this.gridManager = new _CanvasGridManager__WEBPACK_IMPORTED_MODULE_2__.CanvasGridManager();\n        window.canvasGridManager = this.gridManager;\n        this.canvasContainer = document.getElementById('canvasContainer');\n        this.thumbnailContainer = document.getElementById('thumbnailContainer');\n        this.setupEventListeners();\n        // Create initial canvas\n        this.addCanvas();\n    }\n    setupEventListeners() {\n        const addCanvasBtn = document.getElementById('addCanvasBtn');\n        const addCanvasBelowBtn = document.getElementById('addCanvasBelowBtn');\n        addCanvasBtn?.addEventListener('click', () => {\n            this.addCanvas('right');\n        });\n        addCanvasBelowBtn?.addEventListener('click', () => {\n            this.addCanvas('bottom');\n        });\n        // Listen for element movement to re-render canvases\n        document.addEventListener('element-moved', () => {\n            // Always render all canvases to show linked elements\n            this.renderAllCanvases();\n        });\n        // Listen for canvas click events to activate the clicked canvas\n        document.addEventListener('canvas-clicked', (e) => {\n            const customEvent = e;\n            const canvasId = customEvent.detail?.canvasId;\n            if (canvasId && this.canvases.has(canvasId)) {\n                this.setActiveCanvas(canvasId);\n            }\n        });\n        // Listen for element drag events to handle cross-canvas movement\n        document.addEventListener('element-dragging', (e) => {\n            const customEvent = e;\n            const { globalX, globalY, elementId } = customEvent.detail;\n            // Find which canvas the element is being dragged over\n            this.canvases.forEach((canvasManager, canvasId) => {\n                const wrapper = document.getElementById(`wrapper-${canvasId}`);\n                if (!wrapper)\n                    return;\n                const canvas = canvasManager.getCanvas();\n                const rect = canvas.getBoundingClientRect();\n                const containerRect = this.canvasContainer.getBoundingClientRect();\n                // Calculate the canvas bounds in global coordinates\n                const canvasGlobalX = rect.left - containerRect.left;\n                const canvasGlobalY = rect.top - containerRect.top;\n                // Check if the drag position is over this canvas\n                const localX = globalX - canvasManager.getOffset().x;\n                const localY = globalY - canvasManager.getOffset().y;\n                const isOverCanvas = localX >= 0 && localX <= canvas.width &&\n                    localY >= 0 && localY <= canvas.height;\n                if (isOverCanvas && this.activeCanvasId !== canvasId) {\n                    // Check if movement is allowed from active canvas to this canvas\n                    if (this.activeCanvasId && this.gridManager.areCanvasesLinked(this.activeCanvasId, canvasId)) {\n                        // Update element's canvas assignment\n                        const element = this.globalElementManager.getElement(elementId);\n                        if (element) {\n                            this.globalElementManager.updateElement(elementId, { canvasId });\n                            this.setActiveCanvas(canvasId);\n                        }\n                    }\n                }\n            });\n        });\n    }\n    renderAllCanvases() {\n        this.canvases.forEach(canvas => {\n            canvas.render();\n        });\n    }\n    handleElementOverflow(detail) {\n        const { element, canvasId, bounds } = detail;\n        const sourceCanvas = this.canvases.get(canvasId);\n        if (!sourceCanvas)\n            return;\n        // Get canvas position in container\n        const canvasWrapper = document.getElementById(`wrapper-${canvasId}`);\n        if (!canvasWrapper)\n            return;\n        const canvasRect = canvasWrapper.getBoundingClientRect();\n        const containerRect = this.canvasContainer.getBoundingClientRect();\n        // Check for adjacent canvases\n        this.canvases.forEach((targetCanvas, targetId) => {\n            if (targetId === canvasId)\n                return;\n            const targetWrapper = document.getElementById(`wrapper-${targetId}`);\n            if (!targetWrapper)\n                return;\n            const targetRect = targetWrapper.getBoundingClientRect();\n            // Check if element overflows into this canvas\n            if (this.isOverflowing(canvasRect, targetRect, bounds)) {\n                this.createOverflowElement(element, sourceCanvas, targetCanvas, canvasRect, targetRect);\n            }\n        });\n    }\n    isOverflowing(sourceRect, targetRect, bounds) {\n        // Check horizontal overflow (canvas is to the right)\n        if (targetRect.left >= sourceRect.right - 50 && bounds.right > sourceRect.width) {\n            return true;\n        }\n        // Check horizontal overflow (canvas is to the left)\n        if (targetRect.right <= sourceRect.left + 50 && bounds.left < 0) {\n            return true;\n        }\n        return false;\n    }\n    createOverflowElement(element, sourceCanvas, targetCanvas, sourceRect, targetRect) {\n        // Calculate relative position for the overflow element\n        const relativeX = element.x - (targetRect.left - sourceRect.left);\n        const relativeY = element.y;\n        // Create a temporary visual indicator (you can expand this to actually duplicate elements)\n        console.log('Element overflowing from', sourceCanvas.getCanvas().id, 'to', targetCanvas.getCanvas().id);\n    }\n    addCanvas(direction = 'right') {\n        this.canvasCount++;\n        const canvasId = `canvas-${Date.now()}`;\n        const canvasName = ` ${this.canvasCount}`;\n        // Find grid position for new canvas relative to active canvas\n        const gridPos = this.gridManager.findNextPosition(direction, this.activeCanvasId || undefined);\n        // Create main wrapper\n        const wrapper = document.createElement('div');\n        wrapper.className = 'canvas-wrapper';\n        wrapper.id = `wrapper-${canvasId}`;\n        wrapper.setAttribute('data-row', gridPos.row.toString());\n        wrapper.setAttribute('data-col', gridPos.col.toString());\n        // Create title (outside canvas)\n        const title = document.createElement('div');\n        title.className = 'canvas-title';\n        title.contentEditable = 'true';\n        title.textContent = canvasName;\n        title.addEventListener('blur', () => {\n            const data = this.canvasDataMap.get(canvasId);\n            if (data) {\n                data.name = title.textContent || canvasName;\n                this.updateThumbnailLabel(canvasId, data.name);\n            }\n        });\n        // Create canvas content wrapper\n        const canvasContent = document.createElement('div');\n        canvasContent.className = 'canvas-content';\n        // Add click event to canvas content to activate canvas\n        canvasContent.addEventListener('click', (e) => {\n            this.setActiveCanvas(canvasId);\n        });\n        // Create canvas element\n        const canvas = document.createElement('canvas');\n        canvas.id = canvasId;\n        // Assemble the structure: wrapper > [title, canvasContent > canvas]\n        canvasContent.appendChild(canvas);\n        wrapper.appendChild(title);\n        wrapper.appendChild(canvasContent);\n        // Set grid position\n        wrapper.style.gridRow = (gridPos.row + 1).toString();\n        wrapper.style.gridColumn = (gridPos.col + 1).toString();\n        // Don't apply zoom to individual wrappers anymore\n        this.canvasContainer.appendChild(wrapper);\n        // Add canvas to grid FIRST\n        this.gridManager.addCanvas(canvasId, gridPos.row, gridPos.col);\n        // Calculate offset based on grid position (no gap in coordinate system)\n        const offsetX = gridPos.col * this.currentResolution.width;\n        const offsetY = gridPos.row * this.currentResolution.height;\n        // Create CanvasManager instance with global manager and offset\n        const canvasManager = new _CanvasManager__WEBPACK_IMPORTED_MODULE_0__.CanvasManager(canvasId, this.globalElementManager, offsetX, offsetY);\n        this.canvases.set(canvasId, canvasManager);\n        // Create link buttons for this canvas\n        this.createLinkButtons(canvasId);\n        // Also create buttons for adjacent canvases pointing to this new canvas\n        const adjacent = this.gridManager.getAdjacentCanvases(canvasId);\n        adjacent.forEach((adjacentId) => {\n            this.createLinkButtons(adjacentId);\n        });\n        // Store canvas data\n        const canvasData = {\n            id: canvasId,\n            name: canvasName,\n            width: this.currentResolution.width,\n            height: this.currentResolution.height,\n            offsetX: offsetX,\n            offsetY: offsetY\n        };\n        this.canvasDataMap.set(canvasId, canvasData);\n        // Set resolution for the new canvas\n        canvasManager.setResolution(this.currentResolution.width, this.currentResolution.height);\n        // Calculate real offset based on canvas widths only, excluding gaps\n        setTimeout(() => {\n            this.recalculateOffsets();\n        }, 0);\n        // Update total width (only canvas widths, no gaps)\n        this.totalWidth += this.currentResolution.width;\n        // Create thumbnail\n        this.createThumbnail(canvasId, canvasName);\n        // Set as active canvas\n        this.setActiveCanvas(canvasId);\n        // Scroll to the new canvas\n        wrapper.scrollIntoView({ behavior: 'smooth', inline: 'end' });\n    }\n    createThumbnail(canvasId, name) {\n        const thumbnailItem = document.createElement('div');\n        thumbnailItem.className = 'thumbnail-item';\n        thumbnailItem.id = `thumb-${canvasId}`;\n        // Get grid position for this canvas\n        const position = this.gridManager.getCanvasPosition(canvasId);\n        if (position) {\n            // Set grid position for thumbnail\n            thumbnailItem.style.gridColumn = (position.col + 1).toString();\n            thumbnailItem.style.gridRow = (position.row + 1).toString();\n        }\n        // Create thumbnail canvas\n        const thumbCanvas = document.createElement('canvas');\n        thumbCanvas.className = 'thumbnail-canvas';\n        thumbCanvas.width = 120;\n        thumbCanvas.height = 90;\n        // Create label\n        const label = document.createElement('div');\n        label.className = 'thumbnail-label';\n        label.textContent = name;\n        // Create delete button\n        const deleteBtn = document.createElement('button');\n        deleteBtn.className = 'thumbnail-delete';\n        deleteBtn.innerHTML = '';\n        deleteBtn.onclick = (e) => {\n            e.stopPropagation();\n            this.deleteCanvas(canvasId);\n        };\n        thumbnailItem.appendChild(thumbCanvas);\n        thumbnailItem.appendChild(label);\n        thumbnailItem.appendChild(deleteBtn);\n        // Add click handler\n        thumbnailItem.addEventListener('click', () => {\n            this.setActiveCanvas(canvasId);\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            wrapper?.scrollIntoView({ behavior: 'smooth', inline: 'center' });\n        });\n        this.thumbnailContainer.appendChild(thumbnailItem);\n    }\n    setActiveCanvas(canvasId) {\n        // Remove active class from all\n        document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n            wrapper.classList.remove('active');\n        });\n        document.querySelectorAll('.thumbnail-item').forEach(thumb => {\n            thumb.classList.remove('active');\n        });\n        // Add active class to selected\n        const wrapper = document.getElementById(`wrapper-${canvasId}`);\n        const thumbnail = document.getElementById(`thumb-${canvasId}`);\n        wrapper?.classList.add('active');\n        thumbnail?.classList.add('active');\n        this.activeCanvasId = canvasId;\n        // Update thumbnail\n        this.updateThumbnail(canvasId);\n    }\n    updateThumbnail(canvasId) {\n        const canvasManager = this.canvases.get(canvasId);\n        const thumbnail = document.querySelector(`#thumb-${canvasId} .thumbnail-canvas`);\n        if (canvasManager && thumbnail) {\n            const sourceCanvas = document.getElementById(canvasId);\n            if (sourceCanvas) {\n                const ctx = thumbnail.getContext('2d');\n                if (ctx) {\n                    ctx.clearRect(0, 0, thumbnail.width, thumbnail.height);\n                    // Calculate scale to fit\n                    const scale = Math.min(thumbnail.width / sourceCanvas.width, thumbnail.height / sourceCanvas.height);\n                    const scaledWidth = sourceCanvas.width * scale;\n                    const scaledHeight = sourceCanvas.height * scale;\n                    const x = (thumbnail.width - scaledWidth) / 2;\n                    const y = (thumbnail.height - scaledHeight) / 2;\n                    ctx.drawImage(sourceCanvas, x, y, scaledWidth, scaledHeight);\n                }\n            }\n        }\n    }\n    updateThumbnailLabel(canvasId, name) {\n        const label = document.querySelector(`#thumb-${canvasId} .thumbnail-label`);\n        if (label) {\n            label.textContent = name;\n        }\n    }\n    deleteCanvas(canvasId) {\n        if (this.canvases.size <= 1) {\n            alert('   .');\n            return;\n        }\n        if (confirm('  ?')) {\n            // Remove from grid\n            this.gridManager.removeCanvas(canvasId);\n            // Remove from maps\n            this.canvases.delete(canvasId);\n            this.canvasDataMap.delete(canvasId);\n            // Remove DOM elements\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            const thumbnail = document.getElementById(`thumb-${canvasId}`);\n            const linkButton = document.getElementById(`link-${canvasId}`);\n            wrapper?.remove();\n            thumbnail?.remove();\n            linkButton?.remove();\n            // If this was the active canvas, select another\n            if (this.activeCanvasId === canvasId) {\n                const firstCanvasId = this.canvases.keys().next().value;\n                if (firstCanvasId) {\n                    this.setActiveCanvas(firstCanvasId);\n                }\n            }\n            // Recalculate offsets after deletion\n            setTimeout(() => {\n                this.recalculateOffsets();\n            }, 0);\n        }\n    }\n    getActiveCanvas() {\n        if (this.activeCanvasId) {\n            return this.canvases.get(this.activeCanvasId) || null;\n        }\n        return null;\n    }\n    updateAllThumbnails() {\n        this.canvases.forEach((_, canvasId) => {\n            this.updateThumbnail(canvasId);\n        });\n    }\n    setResolutionForAll(width, height) {\n        this.currentResolution = { width, height };\n        // Reset total width\n        this.totalWidth = 0;\n        // Update each canvas with new resolution\n        this.canvases.forEach((canvasManager, canvasId) => {\n            canvasManager.setResolution(width, height);\n            const canvasData = this.canvasDataMap.get(canvasId);\n            if (canvasData) {\n                canvasData.width = width;\n                canvasData.height = height;\n            }\n        });\n        // Recalculate offsets after resolution change\n        setTimeout(() => {\n            this.recalculateOffsets();\n        }, 0);\n        // Update total width based on actual positions\n        this.updateAllThumbnails();\n    }\n    getActiveCanvasResolution() {\n        if (this.activeCanvasId) {\n            const canvasData = this.canvasDataMap.get(this.activeCanvasId);\n            if (canvasData) {\n                return { width: canvasData.width, height: canvasData.height };\n            }\n        }\n        return null;\n    }\n    setZoom(zoomLevel) {\n        const container = this.canvasContainer;\n        if (!container)\n            return;\n        // Clamp zoom level\n        this.currentZoom = Math.max(0.25, Math.min(3, zoomLevel)); // 25% to 300%\n        // Apply scale transformation\n        container.style.transform = `scale(${this.currentZoom})`;\n        container.style.transformOrigin = 'center center';\n        // Update all canvases\n        this.canvases.forEach((canvasManager) => {\n            canvasManager.render();\n        });\n    }\n    updateViewTransform() {\n        const container = this.canvasContainer;\n        if (!container)\n            return;\n        // Apply pan offset\n        container.style.transform = `translate(${this.viewOffset.x}px, ${this.viewOffset.y}px) scale(${this.currentZoom})`;\n        container.style.transformOrigin = '0 0';\n        // Re-render all canvases\n        this.canvases.forEach((canvasManager) => {\n            canvasManager.render();\n        });\n    }\n    setViewOffset(x, y) {\n        this.viewOffset = { x, y };\n        this.updateViewTransform();\n    }\n    panView(dx, dy) {\n        this.viewOffset.x += dx;\n        this.viewOffset.y += dy;\n        this.updateViewTransform();\n    }\n    getViewOffset() {\n        return this.viewOffset;\n    }\n    getZoom() {\n        return this.currentZoom;\n    }\n    getCanvasAtPosition(x, y) {\n        // Find which canvas contains the given screen coordinates\n        for (const [canvasId, canvasManager] of this.canvases) {\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            if (wrapper) {\n                const rect = wrapper.getBoundingClientRect();\n                const canvas = canvasManager.getCanvas();\n                const canvasRect = canvas.getBoundingClientRect();\n                if (x >= canvasRect.left && x <= canvasRect.right &&\n                    y >= canvasRect.top && y <= canvasRect.bottom) {\n                    // Set this as active canvas\n                    this.setActiveCanvas(canvasId);\n                    return canvasManager;\n                }\n            }\n        }\n        return null;\n    }\n    getAllCanvases() {\n        return this.canvases;\n    }\n    createLinkButtons(canvasId) {\n        const wrapper = document.getElementById(`wrapper-${canvasId}`);\n        if (!wrapper)\n            return;\n        const adjacent = this.gridManager.getAdjacentCanvases(canvasId);\n        const position = this.gridManager.getCanvasPosition(canvasId);\n        if (!position)\n            return;\n        // Create link buttons for each adjacent canvas\n        adjacent.forEach((adjacentId, direction) => {\n            // Skip diagonal buttons - we only want orthogonal (horizontal/vertical) links\n            const isDiagonal = direction.includes('-');\n            if (isDiagonal) {\n                return; // Always skip diagonal buttons\n            }\n            // Create a unique ID for the link button between these two canvases\n            const linkId = [canvasId, adjacentId].sort().join('-link-');\n            // Check if this link button already exists anywhere\n            if (document.getElementById(linkId)) {\n                return; // Skip if button already exists\n            }\n            const linkButton = document.createElement('button');\n            linkButton.id = linkId;\n            linkButton.className = `canvas-link-button link-${direction}`;\n            linkButton.title = `Link between ${canvasId} and ${adjacentId}`;\n            // Set position based on direction (positioned in the center of the gap)\n            // Gap is 50px, so buttons should be at -25px (half of gap) - 12px (half of button size)\n            const buttonOffset = '-37px'; // (50px gap / 2) + (24px button / 2)\n            const positions = {\n                'top': { position: 'absolute', top: buttonOffset, left: '50%', transform: 'translateX(-50%)' },\n                'bottom': { position: 'absolute', bottom: buttonOffset, left: '50%', transform: 'translateX(-50%)' },\n                'left': { position: 'absolute', left: buttonOffset, top: '50%', transform: 'translateY(-50%)' },\n                'right': { position: 'absolute', right: buttonOffset, top: '50%', transform: 'translateY(-50%)' },\n                'top-left': { position: 'absolute', top: buttonOffset, left: buttonOffset },\n                'top-right': { position: 'absolute', top: buttonOffset, right: buttonOffset },\n                'bottom-left': { position: 'absolute', bottom: buttonOffset, left: buttonOffset },\n                'bottom-right': { position: 'absolute', bottom: buttonOffset, right: buttonOffset }\n            };\n            const pos = positions[direction];\n            if (pos) {\n                Object.assign(linkButton.style, pos);\n            }\n            // Check if link is enabled\n            const isLinked = this.gridManager.areCanvasesLinked(canvasId, adjacentId);\n            linkButton.classList.toggle('active', isLinked);\n            // Use a simple flat icon\n            linkButton.innerHTML = `<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path d=\"M5.5 8.5L8.5 5.5M6 3.5L4.5 2C3.67157 1.17157 2.32843 1.17157 1.5 2C0.671573 2.82843 0.671573 4.17157 1.5 5L3 6.5M8 10.5L9.5 12C10.3284 12.8284 11.6716 12.8284 12.5 12C13.3284 11.1716 13.3284 9.82843 12.5 9L11 7.5\" \n                      stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n            </svg>`;\n            linkButton.addEventListener('click', () => {\n                const newState = this.gridManager.toggleLink(canvasId, adjacentId);\n                linkButton.classList.toggle('active', newState);\n                // Update corresponding button on the adjacent canvas\n                this.updateCorrespondingLinkButton(adjacentId, canvasId, newState);\n                // Re-render both canvases\n                this.canvases.get(canvasId)?.render();\n                this.canvases.get(adjacentId)?.render();\n            });\n            wrapper.appendChild(linkButton);\n        });\n    }\n    updateCorrespondingLinkButton(canvasId, adjacentId, state) {\n        // Find the link button by its unique ID\n        const linkId = [canvasId, adjacentId].sort().join('-link-');\n        const linkButton = document.getElementById(linkId);\n        if (linkButton) {\n            linkButton.classList.toggle('active', state);\n        }\n    }\n    recalculateOffsets() {\n        // Calculate offsets based on grid positions\n        this.canvases.forEach((canvasManager, canvasId) => {\n            const gridPos = this.gridManager.getCanvasPosition(canvasId);\n            if (gridPos) {\n                // Calculate offset based on grid position (no gap in coordinate system)\n                const offsetX = gridPos.col * this.currentResolution.width;\n                const offsetY = gridPos.row * this.currentResolution.height;\n                canvasManager.setOffset(offsetX, offsetY);\n                // Update canvas data\n                const canvasData = this.canvasDataMap.get(canvasId);\n                if (canvasData) {\n                    canvasData.offsetX = offsetX;\n                    canvasData.offsetY = offsetY;\n                }\n            }\n        });\n    }\n}\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/MultiCanvasManager.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultiCanvasManager */ \"./src/MultiCanvasManager.ts\");\n\n\nclass App {\n    constructor() {\n        this.multiCanvasManager = new _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__.MultiCanvasManager();\n        // Make multiCanvasManager globally accessible for canvases\n        window.multiCanvasManager = this.multiCanvasManager;\n        this.setupEventListeners();\n        // Update thumbnails periodically\n        setInterval(() => {\n            this.multiCanvasManager.updateAllThumbnails();\n        }, 1000);\n    }\n    setupEventListeners() {\n        const addTextBtn = document.getElementById('addTextBtn');\n        const imageUpload = document.getElementById('imageUpload');\n        const clearBtn = document.getElementById('clearBtn');\n        const canvasContainer = document.getElementById('canvasContainer');\n        const canvasWidth = document.getElementById('canvasWidth');\n        const canvasHeight = document.getElementById('canvasHeight');\n        const resolutionPreset = document.getElementById('resolutionPreset');\n        const zoomSlider = document.getElementById('zoomSlider');\n        const zoomValue = document.getElementById('zoomValue');\n        const thumbnailBar = document.getElementById('thumbnailBar');\n        const thumbnailToggle = document.getElementById('thumbnailToggle');\n        addTextBtn?.addEventListener('click', () => {\n            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n            if (activeCanvas) {\n                activeCanvas.addText();\n            }\n        });\n        imageUpload?.addEventListener('change', (e) => {\n            const target = e.target;\n            const file = target.files?.[0];\n            if (file && file.type.startsWith('image/')) {\n                const reader = new FileReader();\n                reader.onload = (event) => {\n                    const imageUrl = event.target?.result;\n                    const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                    if (activeCanvas) {\n                        console.log(`[APP] Adding image to active canvas`);\n                        activeCanvas.addImage(imageUrl);\n                    }\n                    else {\n                        console.error(`[APP] No active canvas to add image to`);\n                    }\n                };\n                reader.readAsDataURL(file);\n            }\n        });\n        clearBtn?.addEventListener('click', () => {\n            if (confirm('  ?')) {\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.clear();\n                }\n            }\n        });\n        // Resolution change handlers\n        const applyResolution = () => {\n            const width = parseInt(canvasWidth.value);\n            const height = parseInt(canvasHeight.value);\n            if (width > 0 && height > 0) {\n                // Set resolution for all canvases to maintain consistency\n                this.multiCanvasManager.setResolutionForAll(width, height);\n            }\n        };\n        canvasWidth?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        canvasHeight?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        resolutionPreset?.addEventListener('change', () => {\n            const value = resolutionPreset.value;\n            if (value !== 'custom') {\n                const [width, height] = value.split('x').map(Number);\n                canvasWidth.value = width.toString();\n                canvasHeight.value = height.toString();\n                applyResolution();\n            }\n        });\n        // Zoom controls\n        zoomSlider?.addEventListener('input', () => {\n            const zoom = parseInt(zoomSlider.value);\n            if (zoomValue) {\n                zoomValue.textContent = `${zoom}%`;\n            }\n            this.multiCanvasManager.setZoom(zoom / 100);\n        });\n        // Thumbnail toggle button\n        thumbnailToggle?.addEventListener('click', () => {\n            thumbnailBar?.classList.toggle('collapsed');\n            const isCollapsed = thumbnailBar?.classList.contains('collapsed');\n            thumbnailToggle.setAttribute('aria-expanded', !isCollapsed ? 'true' : 'false');\n        });\n        // Pan functionality\n        this.setupPanFunctionality(canvasContainer);\n        // Crop button\n        const cropBtn = document.getElementById('cropBtn');\n        cropBtn?.addEventListener('click', () => {\n            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n            if (activeCanvas) {\n                activeCanvas.startCropMode();\n            }\n        });\n        // Show/hide crop button when image is selected\n        document.addEventListener('selection-changed', (e) => {\n            const customEvent = e;\n            const selectedElement = customEvent.detail?.element;\n            if (cropBtn) {\n                cropBtn.style.display = selectedElement?.type === 'image' ? 'block' : 'none';\n            }\n        });\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Delete' || e.key === 'Backspace') {\n                //      \n                const textEditor = document.querySelector('.text-editor-active');\n                if (textEditor) {\n                    console.log(' [Global Delete/Backspace] Text editor is active, ignoring delete');\n                    return; //   \n                }\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.deleteSelected();\n                }\n            }\n        });\n        // Drag and drop for images\n        canvasContainer?.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.add('dragging');\n            // Add visual feedback to the canvas being hovered\n            const targetCanvas = this.multiCanvasManager.getCanvasAtPosition(e.clientX, e.clientY);\n            // Remove drag-over class from all canvases\n            document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n                wrapper.classList.remove('drag-over');\n            });\n            // Add drag-over class to target canvas\n            if (targetCanvas) {\n                const canvases = this.multiCanvasManager.getAllCanvases();\n                for (const [id, canvas] of canvases) {\n                    if (canvas === targetCanvas) {\n                        const wrapper = document.getElementById(`wrapper-${id}`);\n                        wrapper?.classList.add('drag-over');\n                        break;\n                    }\n                }\n            }\n        });\n        canvasContainer?.addEventListener('dragleave', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            // Check if we're actually leaving the container\n            const rect = canvasContainer.getBoundingClientRect();\n            if (e.clientX <= rect.left || e.clientX >= rect.right ||\n                e.clientY <= rect.top || e.clientY >= rect.bottom) {\n                canvasContainer.classList.remove('dragging');\n                document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n                    wrapper.classList.remove('drag-over');\n                });\n            }\n        });\n        canvasContainer?.addEventListener('drop', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.remove('dragging');\n            // Remove drag-over class from all canvases\n            document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n                wrapper.classList.remove('drag-over');\n            });\n            const files = e.dataTransfer?.files;\n            if (files) {\n                // Find which canvas was dropped on\n                const dropX = e.clientX;\n                const dropY = e.clientY;\n                const targetCanvas = this.multiCanvasManager.getCanvasAtPosition(dropX, dropY);\n                for (let i = 0; i < files.length; i++) {\n                    const file = files[i];\n                    if (file.type.startsWith('image/')) {\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            const imageUrl = event.target?.result;\n                            if (targetCanvas) {\n                                targetCanvas.addImage(imageUrl);\n                            }\n                            else {\n                                // Fallback to active canvas if no specific canvas found\n                                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                                if (activeCanvas) {\n                                    activeCanvas.addImage(imageUrl);\n                                }\n                            }\n                        };\n                        reader.readAsDataURL(file);\n                    }\n                }\n            }\n        });\n    }\n    setupPanFunctionality(container) {\n        if (!container)\n            return;\n        let isPanning = false;\n        let isSpacePressed = false;\n        let startX = 0;\n        let startY = 0;\n        let initialOffset = { x: 0, y: 0 };\n        // Remove wheel zoom - only use slider for zoom control\n        // Check if clicking on empty space (not on canvas or elements)\n        const isEmptySpace = (e) => {\n            const target = e.target;\n            // Check if clicking on canvas container background\n            return target.id === 'canvasContainer' ||\n                target.classList.contains('canvas-container');\n        };\n        // Mouse events for panning\n        container.addEventListener('mousedown', (e) => {\n            // Pan with middle mouse OR left click on empty space OR space key\n            if (e.button === 1 || (e.button === 0 && isEmptySpace(e)) || isSpacePressed) {\n                e.preventDefault();\n                isPanning = true;\n                container.style.cursor = 'grabbing';\n                startX = e.clientX;\n                startY = e.clientY;\n                initialOffset = this.multiCanvasManager.getViewOffset();\n            }\n        });\n        window.addEventListener('mousemove', (e) => {\n            if (isPanning) {\n                e.preventDefault();\n                const dx = e.clientX - startX;\n                const dy = e.clientY - startY;\n                this.multiCanvasManager.panView(dx, dy);\n                startX = e.clientX;\n                startY = e.clientY;\n            }\n        });\n        window.addEventListener('mouseup', (e) => {\n            if (isPanning) {\n                isPanning = false;\n                container.style.cursor = 'default';\n            }\n        });\n        // Space key for pan mode (optional, keep for compatibility)\n        document.addEventListener('keydown', (e) => {\n            if (e.code === 'Space' && !isSpacePressed) {\n                e.preventDefault();\n                isSpacePressed = true;\n                container.style.cursor = 'grab';\n            }\n        });\n        document.addEventListener('keyup', (e) => {\n            if (e.code === 'Space') {\n                isSpacePressed = false;\n                if (!isPanning) {\n                    container.style.cursor = 'default';\n                }\n            }\n        });\n        // Prevent context menu on middle click\n        container.addEventListener('contextmenu', (e) => {\n            if (e.button === 1) {\n                e.preventDefault();\n            }\n        });\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    new App();\n});\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/index.ts?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://dynamic-canvas/./src/styles.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;