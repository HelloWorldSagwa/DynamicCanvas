/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n    background: #f7fafc;\n}\n\n#app {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    overflow: hidden;\n}\n\n.toolbar {\n    background: #2d3748;\n    padding: 15px 20px;\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    flex-wrap: wrap;\n    flex-shrink: 0;\n}\n\n.resolution-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-left: auto;\n    color: white;\n}\n\n.zoom-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-left: 20px;\n    color: white;\n    padding: 0 15px;\n    border-left: 1px solid #4a5568;\n}\n\n.zoom-controls label {\n    font-size: 18px;\n    cursor: pointer;\n}\n\n.zoom-controls input[type=\"range\"] {\n    width: 150px;\n    cursor: pointer;\n}\n\n.zoom-controls #zoomValue {\n    min-width: 45px;\n    text-align: right;\n    font-size: 14px;\n    color: #cbd5e0;\n}\n\n.resolution-controls label {\n    font-size: 14px;\n}\n\n.resolution-controls input[type=\"number\"] {\n    width: 80px;\n    padding: 5px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    text-align: center;\n}\n\n.resolution-controls span {\n    color: #cbd5e0;\n}\n\n.resolution-select {\n    padding: 5px 10px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    cursor: pointer;\n}\n\n.tool-btn {\n    background: #4a5568;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 14px;\n    transition: all 0.3s ease;\n}\n\n.tool-btn:hover {\n    background: #718096;\n    transform: translateY(-2px);\n}\n\n.tool-btn.danger {\n    background: #e53e3e;\n}\n\n.tool-btn.danger:hover {\n    background: #fc8181;\n}\n\n/* Sync button styles */\n.sync-btn {\n    background: #6c757d;\n    font-weight: bold;\n    transition: all 0.3s ease;\n}\n\n.sync-btn.active {\n    background: #28a745;\n    animation: pulse 1.5s infinite;\n}\n\n.sync-btn:hover {\n    background: #5a6268;\n}\n\n.sync-btn.active:hover {\n    background: #218838;\n}\n\n@keyframes pulse {\n    0% { opacity: 1; }\n    50% { opacity: 0.8; }\n    100% { opacity: 1; }\n}\n\n.tool-btn.primary {\n    background: #3182ce;\n}\n\n.tool-btn.primary:hover {\n    background: #4299e1;\n}\n\n#cropBtn {\n    background: #9f7aea;\n    display: none;\n}\n\n#cropBtn:hover {\n    background: #b794f4;\n}\n\n.toolbar-separator {\n    width: 1px;\n    height: 30px;\n    background: #4a5568;\n    margin: 0 10px;\n}\n\n.canvas-area {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    padding-top: 0;  /* Remove any padding that might affect positioning */\n    transition: none;  /* Prevent animation when toolbar appears */\n}\n\n.canvas-container {\n    flex: 1;\n    background: linear-gradient(to br, #f0f4f8, #e2e8f0);\n    overflow: auto;\n    padding: 20px;\n    position: relative;\n    display: flex;\n    justify-content: flex-start;\n    align-items: flex-start;\n}\n\n#zoom-wrapper {\n    display: grid;\n    gap: 40px;\n    min-width: fit-content;\n    min-height: fit-content;\n    padding: 200px;\n    grid-auto-flow: row;\n    justify-items: center;\n    align-items: center;\n    width: fit-content;\n    height: fit-content;\n}\n\n.canvas-wrapper {\n    flex-shrink: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    margin: 0 40px;\n    width: fit-content;\n    height: fit-content;\n    gap: 8px;\n    position: relative;\n    transform-origin: center center;\n}\n\n.canvas-title {\n    padding: 8px 15px;\n    background: transparent;\n    color: #2d3748;\n    border-radius: 6px;\n    font-size: 14px;\n    font-weight: 500;\n    cursor: text;\n    min-width: 100px;\n    text-align: center;\n    width: auto;\n    display: inline-block;\n    transition: background 0.2s ease;\n}\n\n.canvas-title:hover {\n    background: #f7fafc;\n}\n\n.canvas-title:focus {\n    outline: 2px solid #3182ce;\n    outline-offset: -2px;\n}\n\n.canvas-content {\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n    padding: 0;\n    cursor: pointer;\n    transition: box-shadow 0.2s ease;\n    position: relative;\n}\n\n.canvas-content:hover {\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n}\n\n.canvas-wrapper.active .canvas-content {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 8px rgba(0,0,0,0.2);\n    cursor: default;\n}\n\n.canvas-content canvas {\n    background: white;\n    cursor: default;\n    image-rendering: crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -webkit-optimize-contrast;\n    display: block;\n    border-radius: 8px;\n    transition: border 0.3s ease, box-shadow 0.3s ease;\n}\n\n.canvas-content canvas.drag-over {\n    border: 3px dashed #3182ce !important;\n    box-shadow: 0 0 20px rgba(49, 130, 206, 0.5) !important;\n}\n\n.canvas-container.dragging {\n    background: #e2e8f0;\n}\n\n.canvas-element {\n    position: absolute;\n    cursor: move;\n    border: 2px solid transparent;\n    padding: 5px;\n    user-select: none;\n}\n\n.canvas-element:hover {\n    border-color: #4299e1;\n}\n\n.canvas-element.selected {\n    border-color: #3182ce;\n    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);\n}\n\n.canvas-element.text {\n    font-size: 24px;\n    color: #2d3748;\n    background: transparent;\n    min-width: 100px;\n    min-height: 30px;\n}\n\n.canvas-element.image {\n    max-width: 300px;\n    max-height: 300px;\n}\n\n.canvas-element img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 10px;\n    height: 10px;\n    background: #3182ce;\n    border: 2px solid white;\n    border-radius: 50%;\n}\n\n.resize-handle.bottom-right {\n    bottom: -5px;\n    right: -5px;\n    cursor: nwse-resize;\n}\n\n.delete-btn {\n    position: absolute;\n    top: -10px;\n    right: -10px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    line-height: 1;\n}\n\n.delete-btn:hover {\n    background: #fc8181;\n}\n\n.text-toolbar {\n    position: fixed;\n    top: 60px;  /* Below main toolbar */\n    left: 0;\n    right: 0;\n    background: #4a5568;\n    padding: 12px 15px;\n    border-bottom: 1px solid #2d3748;\n    z-index: 1000;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n}\n\n.text-controls {\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    justify-content: center;\n}\n\n.text-select {\n    padding: 5px 10px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    cursor: pointer;\n}\n\n.font-size-input {\n    width: 60px;\n    padding: 5px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    text-align: center;\n}\n\n.format-btn {\n    width: 30px;\n    height: 30px;\n    border: none;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.format-btn.italic {\n    font-style: italic;\n}\n\n.format-btn:hover,\n.format-btn.active {\n    background: #3182ce;\n}\n\n.align-group {\n    display: flex;\n    gap: 5px;\n    background: #2d3748;\n    padding: 3px;\n    border-radius: 4px;\n}\n\n.align-btn {\n    width: 30px;\n    height: 26px;\n    border: none;\n    background: transparent;\n    color: white;\n    cursor: pointer;\n    border-radius: 3px;\n    transition: all 0.2s;\n}\n\n.align-btn:hover,\n.align-btn.active {\n    background: #3182ce;\n}\n\n.color-picker {\n    width: 40px;\n    height: 30px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n    background: #3182ce;\n    border: 1px solid white;\n    border-radius: 2px;\n    cursor: pointer;\n}\n\n.resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }\n.resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }\n.resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }\n.resize-handle.e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }\n.resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }\n.resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }\n.resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }\n.resize-handle.w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }\n\n.context-menu {\n    position: fixed;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    z-index: 10000;\n    min-width: 200px;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n}\n\n.context-menu-item {\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: background-color 0.1s;\n    display: flex;\n    align-items: center;\n    color: #2d3748;\n    position: relative;\n}\n\n.context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.context-menu-item span:first-child {\n    width: 20px;\n    text-align: center;\n    margin-right: 8px;\n}\n\n.context-menu-item .shortcut {\n    margin-left: auto;\n    opacity: 0.6;\n    font-size: 11px;\n    padding-left: 20px;\n}\n\n.context-menu-item:hover .shortcut {\n    opacity: 0.9;\n}\n\n.context-menu-separator {\n    height: 1px;\n    background-color: #e2e8f0;\n    margin: 4px 0;\n}\n\n.context-menu-item.has-submenu {\n    position: relative;\n    padding-right: 25px;\n}\n\n.context-menu-item .submenu-arrow {\n    position: absolute;\n    right: 8px;\n    opacity: 0.5;\n    width: auto;\n    margin: 0;\n}\n\n.context-submenu {\n    position: absolute;\n    left: 100%;\n    top: -4px;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    min-width: 180px;\n    display: none;\n}\n\n.context-menu-item.has-submenu:hover .context-submenu {\n    display: block;\n}\n\n.context-submenu .context-menu-item {\n    padding: 8px 12px;\n}\n\n.context-submenu .context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.thumbnail-bar {\n    min-height: 120px;\n    max-height: 300px;\n    height: 120px;\n    background: #2d3748;\n    border-top: 1px solid #1a202c;\n    display: flex;\n    align-items: flex-start;\n    padding: 10px 20px;\n    overflow: auto;\n    flex-shrink: 0;\n    resize: vertical;\n}\n\n.thumbnail-container {\n    display: grid;\n    grid-auto-columns: 140px;\n    grid-auto-rows: 120px;\n    gap: 15px;\n    width: 100%;\n    height: 100%;\n    align-content: start;\n    padding: 10px;\n}\n\n.thumbnail-item {\n    flex-shrink: 0;\n    width: 120px;\n    height: 90px;\n    background: white;\n    border-radius: 6px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.2s;\n}\n\n.thumbnail-item:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n}\n\n.thumbnail-item.active {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 4px rgba(0,0,0,0.2);\n}\n\n.thumbnail-canvas {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.thumbnail-label {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: rgba(0,0,0,0.7);\n    color: white;\n    padding: 2px 5px;\n    font-size: 11px;\n    text-align: center;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.thumbnail-delete {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: none;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n}\n\n.thumbnail-item:hover .thumbnail-delete {\n    display: flex;\n}\n\n.thumbnail-delete:hover {\n    background: #fc8181;\n}\n\n.canvas-link-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 36px;\n    height: 36px;\n    background: white;\n    border: 2px solid #e2e8f0;\n    border-radius: 50%;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    flex-shrink: 0;\n    z-index: 10;\n    place-self: center;\n}\n\n.canvas-link-button.horizontal-link {\n    margin: 0;\n}\n\n.canvas-link-button.vertical-link {\n    margin: 0;\n}\n\n.canvas-link-button:hover {\n    background: #f7fafc;\n    border-color: #cbd5e0;\n    transform: scale(1.1);\n}\n\n.canvas-link-button.active {\n    background: #3182ce;\n    border-color: #3182ce;\n    color: white;\n}\n\n.canvas-link-button.active:hover {\n    background: #2c5282;\n    border-color: #2c5282;\n}\n\n.canvas-link-button svg {\n    width: 20px;\n    height: 20px;\n    pointer-events: none;\n}\n\n.canvas-link-button.active svg {\n    stroke: white;\n}\n\n/* Crop mode styles */\n.crop-mode-toolbar {\n    position: fixed;\n    bottom: 140px; /* Above thumbnail bar */\n    left: 50%;\n    transform: translateX(-50%);\n    background: #2d3748;\n    padding: 12px 20px;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    z-index: 10000;\n}\n\n.crop-mode-toolbar button {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 500;\n    transition: all 0.2s;\n}\n\n.crop-mode-toolbar .apply-crop {\n    background: #48bb78;\n    color: white;\n}\n\n.crop-mode-toolbar .apply-crop:hover {\n    background: #38a169;\n    transform: translateY(-1px);\n}\n\n.crop-mode-toolbar .cancel-crop {\n    background: #e53e3e;\n    color: white;\n}\n\n.crop-mode-toolbar .cancel-crop:hover {\n    background: #c53030;\n    transform: translateY(-1px);\n}\n\n.crop-mode-toolbar .crop-info {\n    color: white;\n    font-size: 13px;\n    margin: 0 10px;\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/CanvasManager.ts":
/*!******************************!*\
  !*** ./src/CanvasManager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasManager: () => (/* binding */ CanvasManager)\n/* harmony export */ });\n/* harmony import */ var _CanvasSyncManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasSyncManager */ \"./src/CanvasSyncManager.ts\");\n\nclass CanvasManager {\n    constructor(canvasId, globalManager, offsetX = 0, offsetY = 0) {\n        this.offsetX = 0; // Canvas offset in global coordinate system\n        this.offsetY = 0;\n        this.scale = 1;\n        // Linking state is tracked by checking link button status\n        // private editingElementId: string | null = null; // Removed - not needed anymore  // Track element being edited\n        this.cropMode = false; // Track crop mode\n        this.cropEdge = null; // Current edge being dragged ('top', 'bottom', 'left', 'right')\n        this.cropStartPoint = { x: 0, y: 0 }; // Start point for crop dragging\n        this.cropStartValue = 0; // Original position of the edge being dragged\n        this.dragState = {\n            isDragging: false,\n            element: null,\n            startPoint: { x: 0, y: 0 },\n            elementStartPoint: { x: 0, y: 0 }\n        };\n        this.resizeState = {\n            isResizing: false,\n            element: null,\n            handle: null,\n            startPoint: { x: 0, y: 0 },\n            originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n        };\n        this.clipboard = null;\n        this.lastContextMenuPosition = { x: 0, y: 0 };\n        this.canvas = document.getElementById(canvasId);\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Failed to get canvas context');\n        }\n        this.ctx = context;\n        this.globalManager = globalManager;\n        this.syncManager = _CanvasSyncManager__WEBPACK_IMPORTED_MODULE_0__.CanvasSyncManager.getInstance();\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.textToolbar = document.getElementById('textToolbar');\n        this.contextMenu = document.getElementById('contextMenu');\n        // Register this canvas for sync updates\n        this.syncManager.registerCanvas(canvasId, () => this.render());\n        // Subscribe to global element changes\n        this.globalManager.subscribe(() => {\n            if (this.syncManager.isSyncEnabled()) {\n                this.render();\n            }\n        });\n        this.setupCanvas();\n        this.setupEventListeners();\n        this.setupTextToolbar();\n        this.setupContextMenu();\n        // Listen for linking state changes\n        document.addEventListener('linking-state-changed', (e) => {\n            const customEvent = e;\n            this.render(); // Re-render when linking state changes\n        });\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isSyncEnabled() {\n        // Use the new CanvasSyncManager\n        const syncManager = window.canvasSyncManager;\n        return syncManager ? syncManager.isSyncEnabled() : false;\n    }\n    setOffset(offsetX, offsetY) {\n        console.log(`[OFFSET] Canvas ${this.canvas.id} offset changing from (${this.offsetX}, ${this.offsetY}) to (${offsetX}, ${offsetY})`);\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.render();\n    }\n    // Convert global coordinates to local canvas coordinates\n    globalToLocal(globalX, globalY) {\n        return {\n            x: globalX - this.offsetX,\n            y: globalY - this.offsetY\n        };\n    }\n    // Convert local canvas coordinates to global coordinates\n    localToGlobal(localX, localY) {\n        console.log(`[COORD] Converting local (${localX}, ${localY}) to global with offset (${this.offsetX}, ${this.offsetY})`);\n        const result = {\n            x: localX + this.offsetX,\n            y: localY + this.offsetY\n        };\n        console.log(`[COORD] Result: global (${result.x}, ${result.y})`);\n        return result;\n    }\n    setupCanvas() {\n        this.setResolution(800, 600);\n    }\n    setResolution(width, height) {\n        // Store the actual resolution\n        this.canvas.width = width;\n        this.canvas.height = height;\n        // Calculate display size based on aspect ratio and viewport\n        this.updateCanvasDisplaySize();\n        // Re-render with new resolution\n        this.render();\n    }\n    updateCanvasDisplaySize() {\n        const canvasContent = this.canvas.parentElement; // canvas-content\n        if (!canvasContent)\n            return;\n        // Maximum available space (accounting for UI elements)\n        // Subtract space for toolbar (approx 70px), thumbnail bar (120px), title (30px), and some padding\n        const maxAvailableWidth = window.innerWidth - 80; // Some padding for scrollbar\n        const maxAvailableHeight = window.innerHeight - 300; // Toolbar + thumbnail bar + title + padding\n        // Calculate the ideal display size\n        const canvasAspectRatio = this.canvas.width / this.canvas.height;\n        let displayWidth;\n        let displayHeight;\n        // Determine the base scale (trying to show canvas at a reasonable size)\n        // Use a base scale that makes sense for typical screen sizes\n        const baseScale = Math.min(maxAvailableWidth / this.canvas.width, maxAvailableHeight / this.canvas.height, 1.0 // Don't scale up beyond 100%\n        );\n        // Apply the scale\n        displayWidth = this.canvas.width * baseScale;\n        displayHeight = this.canvas.height * baseScale;\n        // Ensure minimum size for usability\n        const minWidth = 400;\n        const minHeight = 300;\n        if (displayWidth < minWidth && displayHeight < minHeight) {\n            // Scale up to minimum size while maintaining aspect ratio\n            const minScale = Math.max(minWidth / this.canvas.width, minHeight / this.canvas.height);\n            displayWidth = this.canvas.width * minScale;\n            displayHeight = this.canvas.height * minScale;\n        }\n        // Final scale for mouse position calculations\n        this.scale = displayWidth / this.canvas.width;\n        // Apply calculated dimensions to canvas display\n        this.canvas.style.width = `${displayWidth}px`;\n        this.canvas.style.height = `${displayHeight}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));\n        this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));\n        // Use document-level mouse move and up for better cross-canvas dragging\n        document.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        document.addEventListener('mouseup', this.handleMouseUp.bind(this));\n        // Add click event to activate canvas when clicked\n        this.canvas.addEventListener('click', (e) => {\n            // Dispatch custom event to notify MultiCanvasManager\n            const event = new CustomEvent('canvas-clicked', {\n                detail: { canvasId: this.canvas.id }\n            });\n            document.dispatchEvent(event);\n        });\n        // Add drag and drop support for images\n        this.canvas.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            // Add visual feedback\n            this.canvas.style.border = '3px dashed #3182ce';\n            this.canvas.style.boxShadow = '0 0 10px rgba(49, 130, 206, 0.3)';\n        });\n        this.canvas.addEventListener('dragleave', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            // Remove visual feedback\n            this.canvas.style.border = '';\n            this.canvas.style.boxShadow = '';\n        });\n        this.canvas.addEventListener('drop', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            // Remove visual feedback\n            this.canvas.style.border = '';\n            this.canvas.style.boxShadow = '';\n            // Activate this canvas\n            const clickEvent = new CustomEvent('canvas-clicked', {\n                detail: { canvasId: this.canvas.id }\n            });\n            document.dispatchEvent(clickEvent);\n            // Handle dropped files\n            const files = e.dataTransfer?.files;\n            if (files && files.length > 0) {\n                const file = files[0];\n                if (file.type.startsWith('image/')) {\n                    console.log(`[DROP] File dropped on canvas ${this.canvas.id}: ${file.name}`);\n                    const reader = new FileReader();\n                    reader.onload = (event) => {\n                        const imageUrl = event.target?.result;\n                        // Add image to THIS canvas specifically\n                        console.log(`[DROP] Processing dropped image for canvas ${this.canvas.id}`);\n                        this.addImage(imageUrl);\n                    };\n                    reader.readAsDataURL(file);\n                }\n            }\n        });\n        // Add keyboard event listener for crop mode\n        document.addEventListener('keydown', (e) => {\n            if (this.cropMode) {\n                if (e.key === 'Enter') {\n                    e.preventDefault();\n                    this.applyCrop();\n                }\n                else if (e.key === 'Escape') {\n                    e.preventDefault();\n                    this.cropMode = false;\n                    this.canvas.classList.remove('crop-mode');\n                    this.hideCropToolbar();\n                    this.render();\n                }\n            }\n        });\n        // Add window resize listener for responsive canvas\n        window.addEventListener('resize', () => {\n            this.updateCanvasDisplaySize();\n        });\n        // Listen for linking state changes\n        document.addEventListener('linking-state-changed', (e) => {\n            const customEvent = e;\n            // Linking state changed, re-render\n            this.render();\n            // Re-render when linking state changes\n            this.render();\n        });\n        // Hide context menu when clicking elsewhere\n        document.addEventListener('click', (e) => {\n            if (!this.contextMenu.contains(e.target)) {\n                this.contextMenu.style.display = 'none';\n            }\n        });\n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (e.ctrlKey || e.metaKey) {\n                if (e.key === 'c') {\n                    e.preventDefault();\n                    this.copyElement();\n                }\n                else if (e.key === 'v') {\n                    e.preventDefault();\n                    this.pasteElement();\n                }\n                else if (e.key === 'd') {\n                    e.preventDefault();\n                    this.duplicateElement();\n                }\n            }\n            // Enter key to apply crop\n            if (e.key === 'Enter' && this.cropMode) {\n                e.preventDefault();\n                this.applyCrop();\n            }\n            // Escape key to cancel crop\n            if (e.key === 'Escape' && this.cropMode) {\n                e.preventDefault();\n                this.cropMode = false;\n                this.render();\n            }\n        });\n    }\n    setupTextToolbar() {\n        const fontFamily = document.getElementById('fontFamily');\n        const fontSize = document.getElementById('fontSize');\n        const boldBtn = document.getElementById('boldBtn');\n        const italicBtn = document.getElementById('italicBtn');\n        const alignLeft = document.getElementById('alignLeft');\n        const alignCenter = document.getElementById('alignCenter');\n        const alignRight = document.getElementById('alignRight');\n        const textColor = document.getElementById('textColor');\n        fontFamily?.addEventListener('change', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontFamily: fontFamily.value });\n                this.render();\n            }\n        });\n        fontSize?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontSize: parseInt(fontSize.value) });\n                this.render();\n            }\n        });\n        boldBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontWeight: selectedElement.fontWeight === 'bold' ? 'normal' : 'bold'\n                });\n                boldBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        italicBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontStyle: selectedElement.fontStyle === 'italic' ? 'normal' : 'italic'\n                });\n                italicBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        const alignButtons = [alignLeft, alignCenter, alignRight];\n        const alignValues = ['left', 'center', 'right'];\n        alignButtons.forEach((btn, index) => {\n            btn?.addEventListener('click', () => {\n                const selectedElement = this.globalManager.getSelectedElement();\n                if (selectedElement?.type === 'text') {\n                    this.globalManager.updateElement(selectedElement.id, { textAlign: alignValues[index] });\n                    alignButtons.forEach(b => b?.classList.remove('active'));\n                    btn.classList.add('active');\n                    this.render();\n                }\n            });\n        });\n        textColor?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { color: textColor.value });\n                this.render();\n            }\n        });\n    }\n    updateTextToolbar() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement?.type === 'text') {\n            this.textToolbar.style.display = 'block';\n            const fontFamily = document.getElementById('fontFamily');\n            const fontSize = document.getElementById('fontSize');\n            const boldBtn = document.getElementById('boldBtn');\n            const italicBtn = document.getElementById('italicBtn');\n            const textColor = document.getElementById('textColor');\n            const alignButtons = [\n                document.getElementById('alignLeft'),\n                document.getElementById('alignCenter'),\n                document.getElementById('alignRight')\n            ];\n            if (fontFamily)\n                fontFamily.value = selectedElement.fontFamily || 'Arial';\n            if (fontSize)\n                fontSize.value = (selectedElement.fontSize || 24).toString();\n            if (textColor)\n                textColor.value = selectedElement.color || '#2d3748';\n            boldBtn?.classList.toggle('active', selectedElement.fontWeight === 'bold');\n            italicBtn?.classList.toggle('active', selectedElement.fontStyle === 'italic');\n            const alignIndex = ['left', 'center', 'right'].indexOf(selectedElement.textAlign || 'left');\n            alignButtons.forEach((btn, i) => {\n                btn?.classList.toggle('active', i === alignIndex);\n            });\n        }\n        else {\n            this.textToolbar.style.display = 'none';\n        }\n    }\n    handleMouseDown(e) {\n        // First, activate this canvas\n        const event = new CustomEvent('canvas-clicked', {\n            detail: { canvasId: this.canvas.id }\n        });\n        document.dispatchEvent(event);\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        // Check if we're in crop mode\n        if (this.cropMode) {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && selectedElement.type === 'image') {\n                const localPos = this.globalToLocal(selectedElement.x, selectedElement.y);\n                const edge = this.getImageEdge(localPoint, localPos, selectedElement);\n                if (edge) {\n                    this.cropEdge = edge;\n                    this.cropStartPoint = localPoint;\n                    // Store the original edge position\n                    if (edge === 'left')\n                        this.cropStartValue = selectedElement.cropX || 0;\n                    else if (edge === 'right')\n                        this.cropStartValue = (selectedElement.cropX || 0) + (selectedElement.cropWidth || selectedElement.width);\n                    else if (edge === 'top')\n                        this.cropStartValue = selectedElement.cropY || 0;\n                    else if (edge === 'bottom')\n                        this.cropStartValue = (selectedElement.cropY || 0) + (selectedElement.cropHeight || selectedElement.height);\n                    return;\n                }\n                // Check if clicking inside the crop area\n                const cropX = selectedElement.cropX || 0;\n                const cropY = selectedElement.cropY || 0;\n                const cropWidth = selectedElement.cropWidth || selectedElement.width;\n                const cropHeight = selectedElement.cropHeight || selectedElement.height;\n                if (localPoint.x >= localPos.x + cropX &&\n                    localPoint.x <= localPos.x + cropX + cropWidth &&\n                    localPoint.y >= localPos.y + cropY &&\n                    localPoint.y <= localPos.y + cropY + cropHeight) {\n                    // Clicking inside crop area - do nothing\n                    return;\n                }\n                // Clicking outside crop area (in empty space) - apply crop\n                this.applyCrop();\n                return;\n            }\n        }\n        // Get element at global position\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element) {\n            // Check if we should interact with this element\n            if (element.canvasId !== this.canvas.id && !this.syncManager.isSyncEnabled()) {\n                // Don't select or interact with elements from unlinked canvases\n                return;\n            }\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            if (handle) {\n                this.resizeState = {\n                    isResizing: true,\n                    element: element,\n                    handle: handle,\n                    startPoint: globalPoint,\n                    originalBounds: {\n                        x: element.x,\n                        y: element.y,\n                        width: element.width,\n                        height: element.height,\n                        originalFontSize: element.fontSize\n                    }\n                };\n            }\n            else {\n                console.log(`[DRAG] Starting drag for element ${element.id} (${element.type}) on canvas ${this.canvas.id}`);\n                this.globalManager.setSelectedElement(element.id);\n                this.dragState = {\n                    isDragging: true,\n                    element: element,\n                    startPoint: globalPoint,\n                    elementStartPoint: { x: element.x, y: element.y }\n                };\n                console.log(`[DRAG] Initial position: (${element.x}, ${element.y})`);\n                this.updateTextToolbar();\n                // Dispatch selection changed event\n                const event = new CustomEvent('selection-changed', {\n                    detail: { element: element }\n                });\n                document.dispatchEvent(event);\n            }\n        }\n        else {\n            this.globalManager.setSelectedElement(null);\n            this.updateTextToolbar();\n            // Dispatch selection changed event with null\n            const event = new CustomEvent('selection-changed', {\n                detail: { element: null }\n            });\n            document.dispatchEvent(event);\n        }\n        this.render();\n    }\n    getImageEdge(point, imagePos, element) {\n        const edgeThreshold = 15; // Pixels from edge to be considered clickable\n        const cropX = element.cropX || 0;\n        const cropY = element.cropY || 0;\n        const cropWidth = element.cropWidth || element.width;\n        const cropHeight = element.cropHeight || element.height;\n        // Check if near any edge (considering current crop)\n        const leftEdge = imagePos.x + cropX;\n        const rightEdge = imagePos.x + cropX + cropWidth;\n        const topEdge = imagePos.y + cropY;\n        const bottomEdge = imagePos.y + cropY + cropHeight;\n        // Check each edge\n        if (Math.abs(point.x - leftEdge) <= edgeThreshold &&\n            point.y >= topEdge && point.y <= bottomEdge) {\n            return 'left';\n        }\n        if (Math.abs(point.x - rightEdge) <= edgeThreshold &&\n            point.y >= topEdge && point.y <= bottomEdge) {\n            return 'right';\n        }\n        if (Math.abs(point.y - topEdge) <= edgeThreshold &&\n            point.x >= leftEdge && point.x <= rightEdge) {\n            return 'top';\n        }\n        if (Math.abs(point.y - bottomEdge) <= edgeThreshold &&\n            point.x >= leftEdge && point.x <= rightEdge) {\n            return 'bottom';\n        }\n        return null;\n    }\n    getCursorForEdge(edge) {\n        const cursors = {\n            'left': 'ew-resize',\n            'right': 'ew-resize',\n            'top': 'ns-resize',\n            'bottom': 'ns-resize'\n        };\n        return cursors[edge] || 'default';\n    }\n    handleEdgeCrop(currentPoint, element) {\n        if (!this.cropEdge)\n            return;\n        const dx = currentPoint.x - this.cropStartPoint.x;\n        const dy = currentPoint.y - this.cropStartPoint.y;\n        let cropX = element.cropX || 0;\n        let cropY = element.cropY || 0;\n        let cropWidth = element.cropWidth || element.width;\n        let cropHeight = element.cropHeight || element.height;\n        const minSize = 50; // Minimum size after cropping\n        switch (this.cropEdge) {\n            case 'left':\n                const newLeft = Math.max(0, Math.min(cropX + dx, cropX + cropWidth - minSize));\n                cropWidth = cropWidth - (newLeft - cropX);\n                cropX = newLeft;\n                break;\n            case 'right':\n                cropWidth = Math.max(minSize, Math.min(cropWidth + dx, element.width - cropX));\n                break;\n            case 'top':\n                const newTop = Math.max(0, Math.min(cropY + dy, cropY + cropHeight - minSize));\n                cropHeight = cropHeight - (newTop - cropY);\n                cropY = newTop;\n                break;\n            case 'bottom':\n                cropHeight = Math.max(minSize, Math.min(cropHeight + dy, element.height - cropY));\n                break;\n        }\n        this.globalManager.updateElement(element.id, {\n            cropX: cropX,\n            cropY: cropY,\n            cropWidth: cropWidth,\n            cropHeight: cropHeight\n        });\n        this.cropStartPoint = currentPoint;\n    }\n    handleMouseMove(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        // Handle crop mode interactions\n        if (this.cropMode) {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && selectedElement.type === 'image') {\n                if (this.cropEdge) {\n                    // Handle edge dragging for cropping\n                    this.handleEdgeCrop(localPoint, selectedElement);\n                    this.render();\n                    return;\n                }\n                else {\n                    // Update cursor based on edge proximity\n                    const localPos = this.globalToLocal(selectedElement.x, selectedElement.y);\n                    const edge = this.getImageEdge(localPoint, localPos, selectedElement);\n                    if (edge) {\n                        this.canvas.style.cursor = this.getCursorForEdge(edge);\n                    }\n                    else {\n                        this.canvas.style.cursor = 'default';\n                    }\n                }\n            }\n        }\n        // Only handle if we're actively dragging or resizing from this canvas\n        if (!this.dragState.isDragging && !this.resizeState.isResizing && !this.cropEdge) {\n            // Check for hover effects only if mouse is over this canvas\n            if (e.target === this.canvas && !this.cropMode) {\n                const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n                // Check if element is from an unlinked canvas\n                if (element && element.canvasId !== this.canvas.id && !this.syncManager.isSyncEnabled()) {\n                    this.canvas.style.cursor = 'default';\n                    return;\n                }\n                const selectedElement = this.globalManager.getSelectedElement();\n                const handle = selectedElement && element && element.id === selectedElement.id ?\n                    this.getResizeHandle(localPoint, element) : null;\n                if (handle) {\n                    this.canvas.style.cursor = this.getCursorForHandle(handle);\n                }\n                else if (element && element.type === 'image') {\n                    // Show pointer cursor for images (indicating double-click to crop)\n                    this.canvas.style.cursor = 'pointer';\n                }\n                else {\n                    this.canvas.style.cursor = 'default';\n                }\n            }\n            return;\n        }\n        const rect = this.canvas.getBoundingClientRect();\n        const currentLocalPoint = {\n            x: (e.clientX - rect.left) / this.scale,\n            y: (e.clientY - rect.top) / this.scale\n        };\n        const currentGlobalPoint = this.localToGlobal(currentLocalPoint.x, currentLocalPoint.y);\n        if (this.resizeState.isResizing && this.resizeState.element) {\n            this.handleResize(currentGlobalPoint);\n        }\n        else if (this.dragState.isDragging && this.dragState.element) {\n            const dx = currentGlobalPoint.x - this.dragState.startPoint.x;\n            const dy = currentGlobalPoint.y - this.dragState.startPoint.y;\n            let newX = this.dragState.elementStartPoint.x + dx;\n            let newY = this.dragState.elementStartPoint.y + dy;\n            // If linking is disabled, allow partial hiding but prevent complete loss\n            if (!this.syncManager.isSyncEnabled()) {\n                const element = this.dragState.element;\n                const minVisible = 50; // Minimum pixels that must remain visible\n                // Ensure at least minVisible pixels remain on canvas\n                newX = Math.max(this.offsetX - element.width + minVisible, Math.min(newX, this.offsetX + this.canvas.width - minVisible));\n                newY = Math.max(this.offsetY - element.height + minVisible, Math.min(newY, this.offsetY + this.canvas.height - minVisible));\n            }\n            // Update element's global position\n            console.log(`[DRAG] Moving element ${this.dragState.element.id} to global pos (${newX}, ${newY}) on canvas ${this.canvas.id}`);\n            this.globalManager.updateElement(this.dragState.element.id, {\n                x: newX,\n                y: newY\n            });\n            // Only emit dragging event when linking is enabled\n            if (this.syncManager.isSyncEnabled()) {\n                document.dispatchEvent(new CustomEvent('element-dragging', {\n                    detail: {\n                        elementId: this.dragState.element.id,\n                        globalX: newX,\n                        globalY: newY\n                    }\n                }));\n            }\n            // Trigger re-render on all canvases\n            document.dispatchEvent(new CustomEvent('element-moved'));\n        }\n        else {\n            const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            this.canvas.style.cursor = handle ? this.getCursorForHandle(handle) : 'default';\n        }\n        this.render();\n    }\n    handleElementOverflow(element) {\n        // Emit event for multi-canvas manager to handle overflow\n        const event = new CustomEvent('element-overflow', {\n            detail: {\n                element: element,\n                canvasId: this.canvas.id,\n                bounds: {\n                    left: element.x,\n                    right: element.x + element.width,\n                    top: element.y,\n                    bottom: element.y + element.height\n                }\n            }\n        });\n        document.dispatchEvent(event);\n    }\n    handleResize(point) {\n        if (!this.resizeState.element || !this.resizeState.handle)\n            return;\n        const dx = point.x - this.resizeState.startPoint.x;\n        const dy = point.y - this.resizeState.startPoint.y;\n        const original = this.resizeState.originalBounds;\n        const element = this.resizeState.element;\n        // Check if it's a corner handle for proportional resizing\n        const isCorner = ['nw', 'ne', 'se', 'sw'].includes(this.resizeState.handle);\n        let updates = {};\n        if (isCorner) {\n            // Proportional resizing for corners\n            const aspectRatio = original.width / original.height;\n            let newWidth = original.width;\n            let newHeight = original.height;\n            switch (this.resizeState.handle) {\n                case 'nw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'ne':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'se':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    break;\n                case 'sw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    break;\n            }\n            updates.width = Math.max(20, newWidth);\n            updates.height = Math.max(20, newHeight);\n            // Scale font size for text elements\n            if (element.type === 'text' && element.fontSize) {\n                const scale = newWidth / original.width;\n                updates.fontSize = this.resizeState.originalBounds.originalFontSize * scale;\n            }\n        }\n        else {\n            // Free resizing for edge handles\n            switch (this.resizeState.handle) {\n                case 'n':\n                    updates.y = original.y + dy;\n                    updates.height = original.height - dy;\n                    break;\n                case 'e':\n                    updates.width = original.width + dx;\n                    break;\n                case 's':\n                    updates.height = original.height + dy;\n                    break;\n                case 'w':\n                    updates.x = original.x + dx;\n                    updates.width = original.width - dx;\n                    break;\n            }\n            if (updates.width !== undefined)\n                updates.width = Math.max(20, updates.width);\n            if (updates.height !== undefined)\n                updates.height = Math.max(20, updates.height);\n        }\n        // Update element through global manager\n        this.globalManager.updateElement(element.id, updates);\n        // Trigger re-render on all canvases\n        document.dispatchEvent(new CustomEvent('element-moved'));\n    }\n    getCursorForHandle(handle) {\n        const cursors = {\n            'nw': 'nw-resize',\n            'n': 'n-resize',\n            'ne': 'ne-resize',\n            'e': 'e-resize',\n            'se': 'se-resize',\n            's': 's-resize',\n            'sw': 'sw-resize',\n            'w': 'w-resize'\n        };\n        return cursors[handle];\n    }\n    getResizeHandle(localPoint, element) {\n        if (!element)\n            return null;\n        // Convert element global position to local for handle calculation\n        const localPos = this.globalToLocal(element.x, element.y);\n        const handleSize = 8 / this.scale;\n        const handles = [\n            { handle: 'nw', x: localPos.x, y: localPos.y },\n            { handle: 'n', x: localPos.x + element.width / 2, y: localPos.y },\n            { handle: 'ne', x: localPos.x + element.width, y: localPos.y },\n            { handle: 'e', x: localPos.x + element.width, y: localPos.y + element.height / 2 },\n            { handle: 'se', x: localPos.x + element.width, y: localPos.y + element.height },\n            { handle: 's', x: localPos.x + element.width / 2, y: localPos.y + element.height },\n            { handle: 'sw', x: localPos.x, y: localPos.y + element.height },\n            { handle: 'w', x: localPos.x, y: localPos.y + element.height / 2 }\n        ];\n        for (const h of handles) {\n            if (Math.abs(localPoint.x - h.x) <= handleSize &&\n                Math.abs(localPoint.y - h.y) <= handleSize) {\n                return h.handle;\n            }\n        }\n        return null;\n    }\n    handleMouseUp(e) {\n        // Reset crop states\n        if (this.cropEdge) {\n            this.cropEdge = null;\n            this.render();\n            return;\n        }\n        // Only reset states if this canvas was the one dragging/resizing\n        if (this.dragState.isDragging || this.resizeState.isResizing) {\n            this.dragState = {\n                isDragging: false,\n                element: null,\n                startPoint: { x: 0, y: 0 },\n                elementStartPoint: { x: 0, y: 0 }\n            };\n            this.resizeState = {\n                isResizing: false,\n                element: null,\n                handle: null,\n                startPoint: { x: 0, y: 0 },\n                originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n            };\n            // Re-render all canvases to ensure proper state\n            document.dispatchEvent(new CustomEvent('element-moved'));\n        }\n    }\n    restoreForReCrop(element) {\n        if (element.originalImageElement && element.originalWidth && element.originalHeight) {\n            // Restore to original image for re-cropping\n            this.globalManager.updateElement(element.id, {\n                imageElement: element.originalImageElement,\n                width: element.originalWidth,\n                height: element.originalHeight,\n                content: element.originalContent,\n                hasCropApplied: false,\n                // Restore previous crop coordinates if they exist\n                cropX: element.lastCropX ?? 0,\n                cropY: element.lastCropY ?? 0,\n                cropWidth: element.lastCropWidth ?? element.originalWidth,\n                cropHeight: element.lastCropHeight ?? element.originalHeight\n            });\n        }\n    }\n    handleDoubleClick(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element) {\n            // Check if we should interact with this element\n            if (element.canvasId !== this.canvas.id && !this.syncManager.isSyncEnabled()) {\n                // Don't interact with elements from unlinked canvases\n                return;\n            }\n            if (element.type === 'text') {\n                this.startInlineEditing(element);\n            }\n            else if (element.type === 'image') {\n                if (!this.cropMode) {\n                    // Double-click on image to enter crop mode\n                    this.globalManager.setSelectedElement(element.id);\n                    // If image has been cropped before, restore to pre-crop state for re-editing\n                    if (element.hasCropApplied && element.originalImageElement) {\n                        this.restoreForReCrop(element);\n                    }\n                    this.toggleCropMode();\n                }\n                else {\n                    // If already in crop mode, double-click to apply crop\n                    this.applyCrop();\n                }\n            }\n        }\n    }\n    createInlineTextEditor(globalX, globalY, initialText, fontSize) {\n        // Check if we're already editing\n        const existingEditor = document.querySelector('.text-editor-active');\n        if (existingEditor) {\n            return; // Already editing\n        }\n        // NOTE: For NEW text, we DON'T pre-generate an ID - we'll create it when saving\n        // This avoids confusion with element lookups\n        // Convert global position to local for display\n        const localPos = this.globalToLocal(globalX, globalY);\n        // Create a contentEditable div for inline editing\n        const editor = document.createElement('div');\n        editor.className = 'text-editor-active text-editor-create'; // Add class to identify NEW text editor\n        editor.setAttribute('data-editor-type', 'create');\n        // DON'T set element ID for new text - it doesn't exist yet!\n        editor.contentEditable = 'true';\n        editor.innerText = initialText;\n        editor.style.position = 'fixed';\n        // Calculate position based on canvas position and scale\n        const rect = this.canvas.getBoundingClientRect();\n        const toolbarHeight = this.textToolbar ? this.textToolbar.offsetHeight : 0;\n        const editorTop = rect.top + localPos.y * this.scale;\n        // Check if editor would overlap with toolbar and adjust position\n        let adjustedTop = editorTop;\n        // Text toolbar is at fixed position top: 60px, so check if editor is too high\n        const textToolbarBottom = 60 + (toolbarHeight || 50); // 60px top + toolbar height\n        if (editorTop < textToolbarBottom + 10) {\n            adjustedTop = textToolbarBottom + 20; // Position below toolbar with margin\n        }\n        editor.style.left = `${rect.left + localPos.x * this.scale}px`;\n        editor.style.top = `${adjustedTop}px`;\n        editor.style.minWidth = `${100 * this.scale}px`;\n        editor.style.minHeight = `${fontSize * 1.5 * this.scale}px`;\n        editor.style.maxWidth = `${(this.canvas.width - localPos.x) * this.scale}px`;\n        // Apply text styles\n        editor.style.font = `${fontSize * this.scale}px Arial`;\n        editor.style.color = '#2d3748';\n        editor.style.textAlign = 'left';\n        // Visual styles for better visibility with semi-transparent background\n        editor.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';\n        editor.style.border = '2px solid #3182ce';\n        editor.style.borderRadius = '4px';\n        editor.style.padding = `${5 * this.scale}px`;\n        editor.style.margin = '0';\n        editor.style.zIndex = '10000';\n        editor.style.whiteSpace = 'pre-wrap';\n        editor.style.wordBreak = 'break-word';\n        editor.style.overflow = 'auto';\n        editor.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';\n        editor.style.outline = 'none';\n        editor.style.lineHeight = '1.2';\n        document.body.appendChild(editor);\n        // Select all text\n        editor.focus();\n        const range = document.createRange();\n        range.selectNodeContents(editor);\n        const selection = window.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        let isFinished = false;\n        const finishEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Generate ID only when we're actually creating the element\n            const newElementId = `element-${Date.now()}`;\n            // Get the content - remove zero-width spaces\n            let content = editor.innerText.replace(/\\u200B/g, '').trim();\n            if (!content || content.length === 0) {\n                content = ''; // Default text if empty\n            }\n            // Now create the actual element with the edited content\n            const element = {\n                id: newElementId,\n                type: 'text',\n                x: globalX,\n                y: globalY,\n                width: 200,\n                height: fontSize * 1.5,\n                content: content,\n                fontSize: fontSize,\n                fontFamily: 'Arial',\n                fontWeight: 'normal',\n                fontStyle: 'normal',\n                textAlign: 'left',\n                color: '#2d3748',\n                canvasId: this.canvas.id\n            };\n            // Add element to canvas\n            this.globalManager.addElement(element);\n            this.globalManager.setSelectedElement(element.id);\n            this.updateTextToolbar();\n            // Update dimensions\n            this.updateTextDimensions(element);\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            this.render();\n        };\n        const cancelEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Just remove editor without creating element\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n        };\n        // Track if we should handle blur\n        let shouldHandleBlur = true;\n        let isProcessingKeyboard = false;\n        // Event handlers\n        editor.addEventListener('blur', (e) => {\n            // Don't process blur if we're in the middle of keyboard processing\n            if (isProcessingKeyboard) {\n                return;\n            }\n            // Check if we're clicking on the text toolbar\n            const relatedTarget = e.relatedTarget;\n            if (relatedTarget && this.textToolbar && this.textToolbar.contains(relatedTarget)) {\n                // Refocus the editor if clicking on toolbar\n                setTimeout(() => {\n                    if (document.body.contains(editor)) {\n                        editor.focus();\n                    }\n                }, 0);\n                return;\n            }\n            // Only process blur if we should\n            if (shouldHandleBlur) {\n                // Use requestAnimationFrame to ensure all input events have completed\n                requestAnimationFrame(() => {\n                    if (!isProcessingKeyboard && document.body.contains(editor)) {\n                        finishEditing();\n                    }\n                });\n            }\n        });\n        editor.addEventListener('keydown', (e) => {\n            // Handle special keys\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                cancelEditing();\n                return;\n            }\n            // Enter to confirm (without Shift)\n            if (e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n            // Tab to confirm\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n        });\n        // Handle backspace/delete separately to prevent issues\n        editor.addEventListener('beforeinput', (e) => {\n            // If deleting and text would become empty, prevent default and handle manually\n            if ((e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward')) {\n                const currentText = editor.innerText || '';\n                const selection = window.getSelection()?.toString() || '';\n                // If we're about to delete the last character\n                if (currentText.length <= 1 || (selection === currentText)) {\n                    // Don't prevent default - let it delete, but maintain minimum content\n                    requestAnimationFrame(() => {\n                        const afterDeleteText = editor.innerText || '';\n                        if (!editor.innerText || editor.innerText.length === 0) {\n                            editor.innerHTML = '\\u200B';\n                            // Position cursor at start\n                            const range = document.createRange();\n                            const sel = window.getSelection();\n                            if (editor.firstChild) {\n                                range.setStart(editor.firstChild, 0);\n                                range.collapse(true);\n                                sel?.removeAllRanges();\n                                sel?.addRange(range);\n                            }\n                        }\n                    });\n                }\n            }\n        });\n        // Track composition state for Korean/IME input\n        let isComposing = false;\n        let lastCompositionData = '';\n        editor.addEventListener('compositionstart', (e) => {\n            isComposing = true;\n        });\n        editor.addEventListener('compositionupdate', (e) => {\n            lastCompositionData = e.data || '';\n        });\n        editor.addEventListener('compositionend', (e) => {\n            isComposing = false;\n            // Fix for Korean IME duplication in Chrome/Safari\n            // Check if the last character is duplicated\n            setTimeout(() => {\n                const text = editor.innerText;\n                if (text.length >= 2) {\n                    const lastChar = text[text.length - 1];\n                    const secondLastChar = text[text.length - 2];\n                    // If last two characters are the same and it's a Korean character\n                    if (lastChar === secondLastChar && /[---]/.test(lastChar)) {\n                        // Remove the duplicate\n                        editor.innerText = text.slice(0, -1);\n                        // Restore cursor position to end\n                        const range = document.createRange();\n                        const sel = window.getSelection();\n                        range.selectNodeContents(editor);\n                        range.collapse(false);\n                        sel?.removeAllRanges();\n                        sel?.addRange(range);\n                    }\n                }\n            }, 0);\n        });\n        // Combined input handler for resize only\n        editor.addEventListener('input', (e) => {\n            // Don't manipulate during composition\n            if (isComposing) {\n                return;\n            }\n            // Auto-resize\n            const newHeight = editor.scrollHeight;\n            if (newHeight > parseInt(editor.style.minHeight)) {\n                editor.style.height = `${newHeight}px`;\n            }\n        });\n    }\n    startInlineEditing(element) {\n        if (element.type !== 'text')\n            return;\n        // Get fresh element reference from global manager\n        const currentElement = this.globalManager.getElement(element.id);\n        if (!currentElement) {\n            return;\n        }\n        // Store element ID early for use in attributes\n        const elementId = currentElement.id;\n        // Check if we're already editing this element\n        const existingEditor = document.querySelector('.text-editor-active');\n        if (existingEditor) {\n            return; // Already editing\n        }\n        // Keep the element selected and toolbar visible during editing\n        this.globalManager.setSelectedElement(element.id);\n        this.updateTextToolbar();\n        // Create a contentEditable div for inline editing\n        const editor = document.createElement('div');\n        editor.className = 'text-editor-active text-editor-edit'; // Add class to identify EDIT text editor\n        editor.setAttribute('data-editor-type', 'edit');\n        editor.setAttribute('data-element-id', elementId);\n        editor.contentEditable = 'true';\n        editor.innerText = currentElement.content;\n        editor.style.position = 'fixed';\n        // Calculate position based on canvas position and scale\n        const rect = this.canvas.getBoundingClientRect();\n        const container = this.canvas.parentElement?.getBoundingClientRect();\n        // Convert global element position to local canvas position\n        const localPos = this.globalToLocal(element.x, element.y);\n        // Adjust for container scroll if needed\n        const scrollLeft = this.canvas.parentElement?.scrollLeft || 0;\n        const scrollTop = this.canvas.parentElement?.scrollTop || 0;\n        // Check if editor would overlap with toolbar and adjust position\n        const toolbarHeight = this.textToolbar ? this.textToolbar.offsetHeight : 0;\n        const editorTop = rect.top + (localPos.y - scrollTop) * this.scale;\n        let adjustedTop = editorTop;\n        // Text toolbar is at fixed position top: 60px, so check if editor is too high\n        const textToolbarBottom = 60 + (toolbarHeight || 50); // 60px top + toolbar height\n        if (editorTop < textToolbarBottom + 10) {\n            adjustedTop = Math.max(editorTop, textToolbarBottom + 20); // Keep below toolbar\n        }\n        editor.style.left = `${rect.left + (localPos.x - scrollLeft) * this.scale}px`;\n        editor.style.top = `${adjustedTop}px`;\n        editor.style.minWidth = `${Math.max(100, element.width) * this.scale}px`;\n        editor.style.minHeight = `${element.height * this.scale}px`;\n        editor.style.maxWidth = `${(this.canvas.width - localPos.x) * this.scale}px`;\n        // Apply text styles exactly matching canvas\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        editor.style.font = `${style}${weight}${(element.fontSize || 24) * this.scale}px ${element.fontFamily || 'Arial'}`;\n        editor.style.color = element.color || '#2d3748';\n        editor.style.textAlign = element.textAlign || 'left';\n        // Visual styles for better visibility with semi-transparent background\n        editor.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';\n        editor.style.border = '2px solid #3182ce';\n        editor.style.borderRadius = '4px';\n        editor.style.padding = `${5 * this.scale}px`;\n        editor.style.margin = '0';\n        editor.style.zIndex = '10000';\n        editor.style.whiteSpace = 'pre-wrap';\n        editor.style.wordBreak = 'break-word';\n        editor.style.overflow = 'auto';\n        editor.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';\n        editor.style.outline = 'none';\n        // Line height to match canvas rendering\n        editor.style.lineHeight = '1.2';\n        // Store original content but DON'T hide the canvas text\n        const originalContent = currentElement.content;\n        // elementId already declared above\n        // Don't set editingElementId - keep text visible\n        // this.editingElementId = elementId; // REMOVED - keep text visible\n        // this.render(); // Don't re-render to avoid flicker\n        document.body.appendChild(editor);\n        // Select all text\n        editor.focus();\n        const range = document.createRange();\n        range.selectNodeContents(editor);\n        const selection = window.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        let isFinished = false;\n        const finishEditing = () => {\n            if (isFinished) {\n                return;\n            }\n            isFinished = true;\n            // Get the current content - handle all whitespace properly\n            let rawContent = editor.innerText || editor.textContent || '';\n            // Remove zero-width spaces and normalize\n            let newContent = rawContent.replace(/\\u200B/g, '').replace(/\\u00A0/g, ' ').trim();\n            // Always ensure we have content\n            if (!newContent || newContent.length === 0) {\n                newContent = ''; // Default text if empty\n            }\n            // Get the existing element to preserve its properties\n            const existingElement = this.globalManager.getElement(elementId);\n            if (!existingElement) {\n                if (document.body.contains(editor)) {\n                    document.body.removeChild(editor);\n                }\n                return;\n            }\n            //        \n            // :  ID        \n            this.globalManager.updateElement(elementId, {\n                content: newContent\n            });\n            // Remove editor\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            // Update text dimensions for the updated element\n            const updatedElement = this.globalManager.getElement(elementId);\n            if (updatedElement) {\n                this.updateTextDimensions(updatedElement);\n                // Keep element selected and toolbar visible\n                this.globalManager.setSelectedElement(elementId);\n                this.updateTextToolbar();\n            }\n            this.render();\n        };\n        const cancelEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            // Don't update - just leave the original element as is\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            this.render();\n        };\n        // Track if we should handle blur and keyboard processing\n        let shouldHandleBlur = true;\n        let isProcessingKeyboard = false;\n        let finishingViaKeyboard = false;\n        // Event handlers\n        editor.addEventListener('blur', (e) => {\n            //    blur \n            if (isProcessingKeyboard) {\n                return;\n            }\n            //   \n            if (isFinished) {\n                return;\n            }\n            // Check if we're clicking on the text toolbar\n            const relatedTarget = e.relatedTarget;\n            if (relatedTarget && this.textToolbar && this.textToolbar.contains(relatedTarget)) {\n                // Refocus the editor if clicking on toolbar\n                setTimeout(() => {\n                    if (document.body.contains(editor)) {\n                        editor.focus();\n                    }\n                }, 0);\n                return;\n            }\n            //  finishEditing  ( )\n            finishEditing();\n        });\n        editor.addEventListener('keydown', (e) => {\n            // Handle special keys\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                shouldHandleBlur = false;\n                cancelEditing();\n                return;\n            }\n            // Enter to confirm (without Shift)\n            if (e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                finishingViaKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n            // Tab to confirm\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                isProcessingKeyboard = true;\n                finishingViaKeyboard = true;\n                shouldHandleBlur = false;\n                finishEditing();\n                return;\n            }\n        });\n        // Handle backspace/delete separately to prevent issues\n        editor.addEventListener('beforeinput', (e) => {\n            // If deleting and text would become empty, prevent default and handle manually\n            if ((e.inputType === 'deleteContentBackward' || e.inputType === 'deleteContentForward')) {\n                const currentText = editor.innerText || '';\n                const selection = window.getSelection()?.toString() || '';\n                // If we're about to delete the last character\n                if (currentText.length <= 1 || (selection === currentText)) {\n                    // Don't prevent default - let it delete, but maintain minimum content\n                    requestAnimationFrame(() => {\n                        const afterDeleteText = editor.innerText || '';\n                        if (!editor.innerText || editor.innerText.length === 0) {\n                            editor.innerHTML = '\\u200B';\n                            // Position cursor at start\n                            const range = document.createRange();\n                            const sel = window.getSelection();\n                            if (editor.firstChild) {\n                                range.setStart(editor.firstChild, 0);\n                                range.collapse(true);\n                                sel?.removeAllRanges();\n                                sel?.addRange(range);\n                            }\n                        }\n                    });\n                }\n            }\n        });\n        // Keep toolbar visible during editing\n        editor.addEventListener('focus', () => {\n            this.globalManager.setSelectedElement(elementId);\n            this.updateTextToolbar();\n        });\n        // Track composition state for Korean/IME input\n        let isComposing = false;\n        let lastCompositionData = '';\n        editor.addEventListener('compositionstart', (e) => {\n            isComposing = true;\n        });\n        editor.addEventListener('compositionupdate', (e) => {\n            lastCompositionData = e.data || '';\n        });\n        editor.addEventListener('compositionend', (e) => {\n            isComposing = false;\n            // Fix for Korean IME duplication in Chrome/Safari\n            // Check if the last character is duplicated\n            setTimeout(() => {\n                const text = editor.innerText;\n                if (text.length >= 2) {\n                    const lastChar = text[text.length - 1];\n                    const secondLastChar = text[text.length - 2];\n                    // If last two characters are the same and it's a Korean character\n                    if (lastChar === secondLastChar && /[---]/.test(lastChar)) {\n                        // Remove the duplicate\n                        editor.innerText = text.slice(0, -1);\n                        // Restore cursor position to end\n                        const range = document.createRange();\n                        const sel = window.getSelection();\n                        range.selectNodeContents(editor);\n                        range.collapse(false);\n                        sel?.removeAllRanges();\n                        sel?.addRange(range);\n                    }\n                }\n            }, 0);\n        });\n        // Combined input handler for resize only\n        editor.addEventListener('input', (e) => {\n            // Don't manipulate during composition\n            if (isComposing) {\n                return;\n            }\n            // Auto-resize\n            const newHeight = editor.scrollHeight;\n            if (newHeight > parseInt(editor.style.minHeight)) {\n                editor.style.height = `${newHeight}px`;\n            }\n        });\n        // Update position if canvas scrolls\n        const updatePosition = () => {\n            const rect = this.canvas.getBoundingClientRect();\n            const localPos = this.globalToLocal(currentElement.x, currentElement.y);\n            editor.style.left = `${rect.left + localPos.x * this.scale}px`;\n            editor.style.top = `${rect.top + localPos.y * this.scale}px`;\n        };\n        window.addEventListener('scroll', updatePosition);\n        window.addEventListener('resize', updatePosition);\n        // Clean up scroll listeners when done\n        const originalFinish = finishEditing;\n        const cleanup = () => {\n            window.removeEventListener('scroll', updatePosition);\n            window.removeEventListener('resize', updatePosition);\n        };\n        editor.addEventListener('blur', cleanup);\n    }\n    updateTextDimensions(element) {\n        if (element.type !== 'text')\n            return;\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize || 24}px ${element.fontFamily || 'Arial'}`;\n        // Handle multi-line text\n        const lines = element.content.split('\\n');\n        const lineHeight = (element.fontSize || 24) * 1.2;\n        // Calculate max width from all lines\n        let maxWidth = 0;\n        lines.forEach(line => {\n            const metrics = this.ctx.measureText(line);\n            maxWidth = Math.max(maxWidth, metrics.width);\n        });\n        this.globalManager.updateElement(element.id, {\n            width: maxWidth + 10,\n            height: lineHeight * lines.length\n        });\n        this.ctx.restore();\n    }\n    getMousePosition(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / this.scale;\n        const y = (e.clientY - rect.top) / this.scale;\n        return { x, y };\n    }\n    getElementAtPoint(localPoint) {\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        return this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n    }\n    addText(text = '') {\n        const baseFontSize = 24;\n        // Convert local center position to global position\n        const localCenter = {\n            x: this.canvas.width / 2 - 50,\n            y: this.canvas.height / 2 - baseFontSize / 2\n        };\n        const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n        // Create editor directly without adding element first\n        this.createInlineTextEditor(globalPos.x, globalPos.y, text, baseFontSize);\n    }\n    addImage(imageUrl) {\n        console.log(`[IMAGE] Adding image to canvas ${this.canvas.id}`);\n        console.log(`[IMAGE] Canvas current offset: (${this.offsetX}, ${this.offsetY})`);\n        const img = new Image();\n        img.onload = () => {\n            console.log(`[IMAGE] Image loaded: ${img.width}x${img.height}`);\n            const maxSize = 300;\n            let width = img.width;\n            let height = img.height;\n            if (width > maxSize || height > maxSize) {\n                const ratio = Math.min(maxSize / width, maxSize / height);\n                width *= ratio;\n                height *= ratio;\n                console.log(`[IMAGE] Resized to: ${width}x${height}`);\n            }\n            // Create a copy of the original image for restore functionality\n            const originalImg = new Image();\n            originalImg.src = imageUrl;\n            // Calculate position to center the image in the canvas\n            const localCenter = {\n                x: this.canvas.width / 2 - width / 2,\n                y: this.canvas.height / 2 - height / 2\n            };\n            console.log(`[IMAGE] Canvas size: ${this.canvas.width}x${this.canvas.height}`);\n            console.log(`[IMAGE] Canvas display size: ${this.canvas.style.width} x ${this.canvas.style.height}`);\n            console.log(`[IMAGE] Image size after resize: ${width}x${height}`);\n            console.log(`[IMAGE] Local center position: (${localCenter.x}, ${localCenter.y})`);\n            console.log(`[IMAGE] Current offset BEFORE conversion: (${this.offsetX}, ${this.offsetY})`);\n            const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n            console.log(`[IMAGE] Canvas ${this.canvas.id} - Local pos: (${localCenter.x}, ${localCenter.y}), Global pos: (${globalPos.x}, ${globalPos.y})`);\n            console.log(`[IMAGE] Canvas offset: (${this.offsetX}, ${this.offsetY})`);\n            const element = {\n                id: `element-${Date.now()}`,\n                type: 'image',\n                x: globalPos.x, // Global position\n                y: globalPos.y,\n                width: width,\n                height: height,\n                content: imageUrl,\n                imageElement: img,\n                originalImageElement: originalImg, // Store original\n                originalContent: imageUrl, // Store original URL\n                originalWidth: width,\n                originalHeight: height,\n                canvasId: this.canvas.id,\n                hasCropApplied: false\n            };\n            console.log(`[IMAGE] Adding element to global manager with ID: ${element.id}`);\n            this.globalManager.addElement(element);\n            this.globalManager.setSelectedElement(element.id);\n            console.log(`[IMAGE] Image element added successfully to canvas ${this.canvas.id}`);\n            this.render();\n        };\n        img.src = imageUrl;\n    }\n    clear() {\n        // Clear all elements from global manager\n        this.globalManager.clearAll();\n        this.updateTextToolbar();\n        this.render();\n    }\n    startCropMode() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement && selectedElement.type === 'image') {\n            this.toggleCropMode();\n        }\n    }\n    deleteSelected() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            this.globalManager.removeElement(selectedElement.id);\n            this.updateTextToolbar();\n            this.render();\n        }\n    }\n    render() {\n        console.log(`[RENDER] Starting render for canvas ${this.canvas.id}`);\n        console.log(`[RENDER] Context valid: ${!!this.ctx}, Canvas dimensions: ${this.canvas.width}x${this.canvas.height}`);\n        // Check if canvas is actually in DOM and visible\n        const canvasRect = this.canvas.getBoundingClientRect();\n        console.log(`[RENDER] Canvas client rect: ${canvasRect.width}x${canvasRect.height} at (${canvasRect.x}, ${canvasRect.y})`);\n        if (this.canvas.width === 0 || this.canvas.height === 0) {\n            console.error(`[RENDER] Canvas has zero dimensions! Cannot render.`);\n            return;\n        }\n        this.ctx.save();\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Test drawing - draw a blue rectangle to verify canvas is working\n        this.ctx.fillStyle = 'blue';\n        this.ctx.fillRect(10, 10, 50, 50);\n        console.log(`[RENDER] Drew test blue rectangle at (10, 10, 50, 50)`);\n        // Get all elements that should be visible on this canvas\n        let visibleElements;\n        if (this.syncManager.isSyncEnabled()) {\n            // When sync is enabled, show ALL elements on ALL canvases\n            console.log(`[RENDER-SYNC] Canvas ${this.canvas.id} - Sync ON, showing ALL elements`);\n            visibleElements = this.globalManager.getAllElements();\n        }\n        else {\n            // When sync is disabled, only show elements within this canvas's bounds\n            console.log(`[RENDER] Canvas ${this.canvas.id} - Sync OFF, checking visibility with offset (${this.offsetX}, ${this.offsetY})`);\n            visibleElements = this.globalManager.getElementsForCanvas(this.offsetX, this.offsetY, this.canvas.width, this.canvas.height);\n        }\n        console.log(`[RENDER] Canvas ${this.canvas.id} - Found ${visibleElements.length} visible elements`);\n        // Render each visible element\n        for (const element of visibleElements) {\n            // Check if element should be rendered\n            if (element.canvasId !== this.canvas.id) {\n                // Element is from another canvas\n                // Only render if linking is enabled between the canvases\n                if (!this.syncManager.isSyncEnabled()) {\n                    // Skip unless it's being dragged by this canvas\n                    if (!this.dragState.isDragging || this.dragState.element?.id !== element.id) {\n                        continue;\n                    }\n                }\n            }\n            this.ctx.save();\n            // Convert element's global position to local position for rendering\n            const localPos = this.globalToLocal(element.x, element.y);\n            const localElement = { ...element, x: localPos.x, y: localPos.y };\n            console.log(`[RENDER-ELEMENT] Processing element ${element.id}, type: ${element.type}`);\n            console.log(`[RENDER-ELEMENT] Has imageElement: ${!!element.imageElement}, localElement has imageElement: ${!!localElement.imageElement}`);\n            if (element.type === 'text') {\n                this.renderText(localElement);\n            }\n            else if (element.type === 'image') {\n                if (!element.imageElement) {\n                    console.error(`[RENDER] Image element ${element.id} has no imageElement!`);\n                }\n                else {\n                    console.log(`[RENDER] Rendering image ${element.id} on canvas ${this.canvas.id} at local pos (${localElement.x}, ${localElement.y})`);\n                    console.log(`[RENDER] Image src: ${element.imageElement.src?.substring(0, 50)}...`);\n                    this.renderImage(localElement);\n                }\n            }\n            // Render selection if this element is selected (but not in crop mode for images)\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && element.id === selectedElement.id) {\n                // Don't show regular selection handles for images in crop mode\n                if (!(this.cropMode && element.type === 'image')) {\n                    this.renderSelection(localElement);\n                    this.renderResizeHandles(localElement);\n                }\n            }\n            this.ctx.restore();\n        }\n        // Final restore to match the save at the beginning of render\n        this.ctx.restore();\n        console.log(`[RENDER] Render complete for canvas ${this.canvas.id}`);\n    }\n    renderText(element) {\n        // Don't skip rendering - always show text even during editing\n        // This allows the text to remain visible behind the edit overlay\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize}px ${element.fontFamily}`;\n        this.ctx.fillStyle = element.color || '#000000';\n        // Handle multi-line text\n        const lines = element.content.split('\\n');\n        const lineHeight = (element.fontSize || 24) * 1.2;\n        // Calculate total width and height\n        let maxWidth = 0;\n        lines.forEach(line => {\n            const metrics = this.ctx.measureText(line);\n            maxWidth = Math.max(maxWidth, metrics.width);\n        });\n        element.width = maxWidth + 10; // Reduced padding\n        element.height = lineHeight * lines.length;\n        // Render each line - allow rendering outside canvas bounds\n        lines.forEach((line, index) => {\n            let textX = element.x + 5;\n            if (element.textAlign === 'center') {\n                textX = element.x + element.width / 2;\n                this.ctx.textAlign = 'center';\n            }\n            else if (element.textAlign === 'right') {\n                textX = element.x + element.width - 5;\n                this.ctx.textAlign = 'right';\n            }\n            else {\n                this.ctx.textAlign = 'left';\n            }\n            const textY = element.y + lineHeight * (index + 0.5);\n            this.ctx.textBaseline = 'middle';\n            // Draw text even if it goes outside canvas bounds\n            this.ctx.fillText(line, textX, textY);\n        });\n        this.ctx.restore();\n    }\n    renderImage(element) {\n        if (!element.imageElement) {\n            console.warn(`[RENDER] No imageElement for ${element.id}`);\n            return;\n        }\n        console.log(`[RENDER-IMAGE] Drawing image ${element.id}:`);\n        console.log(`  Canvas: ${this.canvas.id}, Canvas size: ${this.canvas.width}x${this.canvas.height}`);\n        console.log(`  Position: (${element.x}, ${element.y}), Size: ${element.width}x${element.height}`);\n        console.log(`  Image loaded: ${element.imageElement.complete}, Natural size: ${element.imageElement.naturalWidth}x${element.imageElement.naturalHeight}`);\n        // Check if image is actually loaded\n        if (!element.imageElement.complete || element.imageElement.naturalWidth === 0) {\n            console.warn(`[RENDER-IMAGE] Image not loaded yet for ${element.id}`);\n            // Try to reload the image\n            element.imageElement.onload = () => {\n                console.log(`[RENDER-IMAGE] Image loaded, triggering re-render`);\n                this.render();\n            };\n            return;\n        }\n        // Always render full image when in crop mode\n        if (this.cropMode && this.globalManager.getSelectedElement()?.id === element.id) {\n            // In crop mode, show full image with overlay\n            this.ctx.drawImage(element.imageElement, element.x, element.y, element.width, element.height);\n            // Render crop overlay\n            this.renderCropOverlay(element);\n        }\n        else if (element.cropX !== undefined && element.cropY !== undefined &&\n            element.cropWidth !== undefined && element.cropHeight !== undefined) {\n            // After crop applied, show only cropped portion\n            this.ctx.drawImage(element.imageElement, element.cropX, element.cropY, // Source position\n            element.cropWidth, element.cropHeight, // Source dimensions\n            element.x, element.y, // Destination position\n            element.width, element.height // Destination dimensions\n            );\n        }\n        else {\n            // Render full image normally\n            console.log(`[RENDER-IMAGE] Calling ctx.drawImage at (${element.x}, ${element.y})`);\n            console.log(`[RENDER-IMAGE] Context state - globalAlpha: ${this.ctx.globalAlpha}, fillStyle: ${this.ctx.fillStyle}`);\n            // Ensure context is in proper state\n            this.ctx.globalAlpha = 1.0;\n            try {\n                this.ctx.drawImage(element.imageElement, element.x, element.y, element.width, element.height);\n                // Debug: Draw a red border around where the image should be\n                this.ctx.strokeStyle = 'red';\n                this.ctx.lineWidth = 2;\n                this.ctx.strokeRect(element.x, element.y, element.width, element.height);\n                console.log(`[RENDER-IMAGE] Drew debug border at (${element.x}, ${element.y}, ${element.width}, ${element.height})`);\n            }\n            catch (e) {\n                console.error(`[RENDER-IMAGE] Error drawing image:`, e);\n            }\n        }\n        console.log(`[RENDER-IMAGE] Draw complete for ${element.id}`);\n    }\n    renderCropOverlay(element) {\n        if (!this.cropMode || element.type !== 'image') {\n            return;\n        }\n        const cropX = element.cropX || 0;\n        const cropY = element.cropY || 0;\n        const cropWidth = element.cropWidth || element.width;\n        const cropHeight = element.cropHeight || element.height;\n        // element.x and element.y are already in local coordinates\n        const localX = element.x;\n        const localY = element.y;\n        // Save context state\n        this.ctx.save();\n        // Draw the cropped areas with red semi-transparent overlay\n        this.ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';\n        // Areas that will be cropped (outside the crop region)\n        if (cropX > 0) {\n            // Left cropped area\n            this.ctx.fillRect(localX, localY, cropX, element.height);\n        }\n        if (cropX + cropWidth < element.width) {\n            // Right cropped area\n            this.ctx.fillRect(localX + cropX + cropWidth, localY, element.width - cropX - cropWidth, element.height);\n        }\n        if (cropY > 0) {\n            // Top cropped area\n            this.ctx.fillRect(localX + cropX, localY, cropWidth, cropY);\n        }\n        if (cropY + cropHeight < element.height) {\n            // Bottom cropped area\n            this.ctx.fillRect(localX + cropX, localY + cropY + cropHeight, cropWidth, element.height - cropY - cropHeight);\n        }\n        // Draw edge indicators\n        const edgeWidth = 4;\n        this.ctx.strokeStyle = '#ff4444';\n        this.ctx.lineWidth = edgeWidth;\n        this.ctx.setLineDash([10, 5]);\n        // Draw crop boundaries\n        if (cropX > 0) {\n            // Left edge\n            this.ctx.beginPath();\n            this.ctx.moveTo(localX + cropX, localY);\n            this.ctx.lineTo(localX + cropX, localY + element.height);\n            this.ctx.stroke();\n        }\n        if (cropX + cropWidth < element.width) {\n            // Right edge\n            this.ctx.beginPath();\n            this.ctx.moveTo(localX + cropX + cropWidth, localY);\n            this.ctx.lineTo(localX + cropX + cropWidth, localY + element.height);\n            this.ctx.stroke();\n        }\n        if (cropY > 0) {\n            // Top edge\n            this.ctx.beginPath();\n            this.ctx.moveTo(localX, localY + cropY);\n            this.ctx.lineTo(localX + element.width, localY + cropY);\n            this.ctx.stroke();\n        }\n        if (cropY + cropHeight < element.height) {\n            // Bottom edge\n            this.ctx.beginPath();\n            this.ctx.moveTo(localX, localY + cropY + cropHeight);\n            this.ctx.lineTo(localX + element.width, localY + cropY + cropHeight);\n            this.ctx.stroke();\n        }\n        this.ctx.setLineDash([]);\n        // Draw the final crop area border\n        this.ctx.strokeStyle = '#3182ce';\n        this.ctx.lineWidth = 2;\n        this.ctx.strokeRect(localX + cropX, localY + cropY, cropWidth, cropHeight);\n        // Draw drag handles on edges\n        this.drawEdgeHandles(localX, localY, element, cropX, cropY, cropWidth, cropHeight);\n        // Display crop info\n        const cropText = ` : ${Math.round(cropWidth)}  ${Math.round(cropHeight)}`;\n        this.ctx.font = 'bold 14px Arial';\n        const textMetrics = this.ctx.measureText(cropText);\n        const padding = 8;\n        const textX = localX + cropX + cropWidth / 2;\n        const textY = localY + cropY + cropHeight / 2;\n        // Background for text\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        this.ctx.fillRect(textX - textMetrics.width / 2 - padding, textY - 10, textMetrics.width + padding * 2, 24);\n        // Text\n        this.ctx.fillStyle = '#ffffff';\n        this.ctx.textAlign = 'center';\n        this.ctx.textBaseline = 'middle';\n        this.ctx.fillText(cropText, textX, textY);\n        this.ctx.textAlign = 'start';\n        this.ctx.textBaseline = 'alphabetic';\n        // Restore context state\n        this.ctx.restore();\n    }\n    drawEdgeHandles(imageX, imageY, element, cropX, cropY, cropWidth, cropHeight) {\n        const handleLength = 40;\n        const handleWidth = 8;\n        this.ctx.fillStyle = '#3182ce';\n        this.ctx.strokeStyle = '#ffffff';\n        this.ctx.lineWidth = 1;\n        // Left edge handle (if can crop from left)\n        if (cropX > 0 || cropWidth < element.width) {\n            const leftX = imageX + cropX;\n            const leftY = imageY + cropY + cropHeight / 2;\n            this.ctx.fillRect(leftX - handleWidth / 2, leftY - handleLength / 2, handleWidth, handleLength);\n            this.ctx.strokeRect(leftX - handleWidth / 2, leftY - handleLength / 2, handleWidth, handleLength);\n        }\n        // Right edge handle\n        if (cropX + cropWidth < element.width || cropX > 0) {\n            const rightX = imageX + cropX + cropWidth;\n            const rightY = imageY + cropY + cropHeight / 2;\n            this.ctx.fillRect(rightX - handleWidth / 2, rightY - handleLength / 2, handleWidth, handleLength);\n            this.ctx.strokeRect(rightX - handleWidth / 2, rightY - handleLength / 2, handleWidth, handleLength);\n        }\n        // Top edge handle\n        if (cropY > 0 || cropHeight < element.height) {\n            const topX = imageX + cropX + cropWidth / 2;\n            const topY = imageY + cropY;\n            this.ctx.fillRect(topX - handleLength / 2, topY - handleWidth / 2, handleLength, handleWidth);\n            this.ctx.strokeRect(topX - handleLength / 2, topY - handleWidth / 2, handleLength, handleWidth);\n        }\n        // Bottom edge handle\n        if (cropY + cropHeight < element.height || cropY > 0) {\n            const bottomX = imageX + cropX + cropWidth / 2;\n            const bottomY = imageY + cropY + cropHeight;\n            this.ctx.fillRect(bottomX - handleLength / 2, bottomY - handleWidth / 2, handleLength, handleWidth);\n            this.ctx.strokeRect(bottomX - handleLength / 2, bottomY - handleWidth / 2, handleLength, handleWidth);\n        }\n    }\n    renderSelection(element) {\n        this.ctx.strokeStyle = '#3182ce';\n        this.ctx.lineWidth = 2;\n        this.ctx.setLineDash([5, 5]);\n        this.ctx.strokeRect(element.x, element.y, element.width, element.height);\n        this.ctx.setLineDash([]);\n    }\n    renderResizeHandles(element) {\n        const handles = [\n            { x: element.x, y: element.y },\n            { x: element.x + element.width / 2, y: element.y },\n            { x: element.x + element.width, y: element.y },\n            { x: element.x + element.width, y: element.y + element.height / 2 },\n            { x: element.x + element.width, y: element.y + element.height },\n            { x: element.x + element.width / 2, y: element.y + element.height },\n            { x: element.x, y: element.y + element.height },\n            { x: element.x, y: element.y + element.height / 2 }\n        ];\n        this.ctx.fillStyle = '#3182ce';\n        this.ctx.strokeStyle = 'white';\n        this.ctx.lineWidth = 1;\n        handles.forEach(handle => {\n            this.ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);\n            this.ctx.strokeRect(handle.x - 4, handle.y - 4, 8, 8);\n        });\n    }\n    setupContextMenu() {\n        // Handle menu item clicks using event delegation\n        this.contextMenu.addEventListener('click', (e) => {\n            const target = e.target;\n            const menuItem = target.closest('.context-menu-item');\n            if (!menuItem || menuItem.classList.contains('has-submenu')) {\n                return;\n            }\n            e.stopPropagation();\n            const action = menuItem.dataset.action;\n            switch (action) {\n                case 'bring-front':\n                    this.bringToFront();\n                    break;\n                case 'bring-forward':\n                    this.bringForward();\n                    break;\n                case 'send-backward':\n                    this.sendBackward();\n                    break;\n                case 'send-back':\n                    this.sendToBack();\n                    break;\n                case 'duplicate':\n                    this.duplicateElement();\n                    break;\n                case 'copy':\n                    this.copyElement();\n                    break;\n                case 'paste':\n                    this.pasteElement();\n                    break;\n                case 'delete':\n                    this.deleteSelected();\n                    break;\n                case 'crop':\n                    this.toggleCropMode();\n                    break;\n                case 'apply-crop':\n                    this.applyCrop();\n                    break;\n            }\n            this.contextMenu.style.display = 'none';\n            this.render();\n        });\n        // Prevent context menu from closing when hovering over submenu\n        this.contextMenu.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        });\n    }\n    handleContextMenu(e) {\n        e.preventDefault();\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        // Store click position for paste (in global coordinates)\n        this.lastContextMenuPosition = globalPoint;\n        if (element) {\n            // Show full menu for elements\n            this.globalManager.setSelectedElement(element.id);\n            this.updateTextToolbar();\n            // Show all menu items, but hide crop if not an image\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                const action = item.dataset.action;\n                if (action === 'crop' && element.type !== 'image') {\n                    item.style.display = 'none';\n                }\n                else {\n                    item.style.display = '';\n                }\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = '';\n            });\n        }\n        else {\n            // Show limited menu for empty space (only paste)\n            this.globalManager.setSelectedElement(null);\n            this.updateTextToolbar();\n            // Hide all items except paste\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                const action = item.dataset.action;\n                if (action === 'paste' && this.clipboard) {\n                    item.style.display = '';\n                }\n                else {\n                    item.style.display = 'none';\n                }\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = 'none';\n            });\n        }\n        // Position context menu exactly at mouse cursor\n        this.contextMenu.style.left = `${e.clientX}px`;\n        this.contextMenu.style.top = `${e.clientY}px`;\n        this.contextMenu.style.display = 'block';\n        // Ensure menu stays within viewport\n        requestAnimationFrame(() => {\n            const menuRect = this.contextMenu.getBoundingClientRect();\n            let adjustedX = e.clientX;\n            let adjustedY = e.clientY;\n            // Adjust horizontal position if menu goes off right edge\n            if (menuRect.right > window.innerWidth) {\n                adjustedX = Math.max(0, window.innerWidth - menuRect.width - 5);\n            }\n            // Adjust vertical position if menu goes off bottom edge\n            if (menuRect.bottom > window.innerHeight) {\n                adjustedY = Math.max(0, window.innerHeight - menuRect.height - 5);\n            }\n            if (adjustedX !== e.clientX || adjustedY !== e.clientY) {\n                this.contextMenu.style.left = `${adjustedX}px`;\n                this.contextMenu.style.top = `${adjustedY}px`;\n            }\n        });\n        this.render();\n    }\n    bringToFront() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    bringForward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to front (can be improved with layer ordering)\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    sendBackward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to back (can be improved with layer ordering)\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    sendToBack() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    copyElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            this.clipboard = { ...selectedElement };\n        }\n    }\n    pasteElement() {\n        if (this.clipboard) {\n            const newElement = {\n                ...this.clipboard,\n                id: `element-${Date.now()}`,\n                x: this.lastContextMenuPosition.x || this.clipboard.x + 20,\n                y: this.lastContextMenuPosition.y || this.clipboard.y + 20,\n                canvasId: this.canvas.id\n            };\n            // If it's an image, clone the image element\n            if (newElement.type === 'image' && this.clipboard.imageElement) {\n                const img = new Image();\n                img.src = this.clipboard.imageElement.src;\n                newElement.imageElement = img;\n            }\n            this.globalManager.addElement(newElement);\n            this.globalManager.setSelectedElement(newElement.id);\n            this.updateTextToolbar();\n        }\n    }\n    duplicateElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            const duplicate = this.globalManager.duplicateElement(selectedElement.id, 20, 20);\n            if (duplicate) {\n                this.globalManager.setSelectedElement(duplicate.id);\n                this.updateTextToolbar();\n            }\n        }\n    }\n    toggleCropMode() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement || selectedElement.type !== 'image') {\n            return;\n        }\n        this.cropMode = !this.cropMode;\n        this.cropEdge = null;\n        if (this.cropMode) {\n            // Store original dimensions and image if not already stored\n            if (!selectedElement.originalImageElement && selectedElement.imageElement) {\n                const originalImg = new Image();\n                originalImg.src = selectedElement.imageElement.src;\n                this.globalManager.updateElement(selectedElement.id, {\n                    originalImageElement: originalImg,\n                    originalContent: selectedElement.content,\n                    originalWidth: selectedElement.width,\n                    originalHeight: selectedElement.height\n                });\n            }\n            // If crop coordinates are already set (from restoreForReCrop), keep them\n            // Otherwise, initialize with full image\n            if (selectedElement.cropX === undefined) {\n                this.globalManager.updateElement(selectedElement.id, {\n                    cropX: 0,\n                    cropY: 0,\n                    cropWidth: selectedElement.width,\n                    cropHeight: selectedElement.height\n                });\n            }\n            // Add crop mode class to canvas for styling\n            this.canvas.classList.add('crop-mode');\n            // Show crop toolbar\n            this.showCropToolbar();\n        }\n        else {\n            // Remove crop mode class\n            this.canvas.classList.remove('crop-mode');\n            // Clear crop coordinates when exiting crop mode without applying\n            if (!selectedElement.hasCropApplied) {\n                this.globalManager.updateElement(selectedElement.id, {\n                    cropX: undefined,\n                    cropY: undefined,\n                    cropWidth: undefined,\n                    cropHeight: undefined\n                });\n            }\n            // Hide crop toolbar\n            this.hideCropToolbar();\n        }\n        this.render();\n    }\n    showCropToolbar() {\n        // Remove existing toolbar if any\n        this.hideCropToolbar();\n        const toolbar = document.createElement('div');\n        toolbar.className = 'crop-mode-toolbar';\n        toolbar.id = 'cropToolbar';\n        const applyBtn = document.createElement('button');\n        applyBtn.className = 'apply-crop';\n        applyBtn.textContent = ' ';\n        applyBtn.onclick = () => this.applyCrop();\n        const resetBtn = document.createElement('button');\n        resetBtn.className = 'reset-crop';\n        resetBtn.textContent = ' ';\n        resetBtn.onclick = () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement) {\n                // Reset to full image size\n                this.globalManager.updateElement(selectedElement.id, {\n                    cropX: 0,\n                    cropY: 0,\n                    cropWidth: selectedElement.width,\n                    cropHeight: selectedElement.height\n                });\n                this.render();\n            }\n        };\n        const cancelBtn = document.createElement('button');\n        cancelBtn.className = 'cancel-crop';\n        cancelBtn.textContent = ' ';\n        cancelBtn.onclick = () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement) {\n                // If crop was previously applied, restore to the cropped state\n                if (selectedElement.hasCropApplied && selectedElement.content) {\n                    const restoredImg = new Image();\n                    restoredImg.onload = () => {\n                        this.globalManager.updateElement(selectedElement.id, {\n                            imageElement: restoredImg,\n                            width: selectedElement.lastCropWidth || selectedElement.width,\n                            height: selectedElement.lastCropHeight || selectedElement.height,\n                            cropX: undefined,\n                            cropY: undefined,\n                            cropWidth: undefined,\n                            cropHeight: undefined\n                        });\n                        this.cropMode = false;\n                        this.canvas.classList.remove('crop-mode');\n                        this.hideCropToolbar();\n                        this.render();\n                    };\n                    restoredImg.src = selectedElement.content;\n                }\n                else {\n                    // If no crop was applied, just clear the crop coordinates\n                    this.globalManager.updateElement(selectedElement.id, {\n                        cropX: undefined,\n                        cropY: undefined,\n                        cropWidth: undefined,\n                        cropHeight: undefined\n                    });\n                    this.cropMode = false;\n                    this.canvas.classList.remove('crop-mode');\n                    this.hideCropToolbar();\n                    this.render();\n                }\n            }\n        };\n        const infoSpan = document.createElement('span');\n        infoSpan.className = 'crop-info';\n        infoSpan.textContent = '  ';\n        toolbar.appendChild(applyBtn);\n        toolbar.appendChild(resetBtn);\n        toolbar.appendChild(infoSpan);\n        toolbar.appendChild(cancelBtn);\n        document.body.appendChild(toolbar);\n    }\n    hideCropToolbar() {\n        const toolbar = document.getElementById('cropToolbar');\n        if (toolbar) {\n            toolbar.remove();\n        }\n    }\n    applyCrop() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement || selectedElement.type !== 'image' || !this.cropMode) {\n            return;\n        }\n        // Apply the crop by creating a new cropped image\n        if (selectedElement.cropX !== undefined && selectedElement.cropY !== undefined &&\n            selectedElement.cropWidth && selectedElement.cropHeight && selectedElement.imageElement) {\n            // Get the original image dimensions (not the display dimensions)\n            const originalImg = selectedElement.imageElement;\n            // Calculate scale between display size and original image size\n            const scaleX = originalImg.naturalWidth / selectedElement.width;\n            const scaleY = originalImg.naturalHeight / selectedElement.height;\n            // Create a temporary canvas for cropping with the cropped dimensions\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = selectedElement.cropWidth;\n            tempCanvas.height = selectedElement.cropHeight;\n            const tempCtx = tempCanvas.getContext('2d');\n            if (tempCtx) {\n                // Draw the cropped portion of the image\n                // Use the original image and scale the crop coordinates\n                tempCtx.drawImage(originalImg, selectedElement.cropX * scaleX, // Source X (scaled to original)\n                selectedElement.cropY * scaleY, // Source Y (scaled to original)\n                selectedElement.cropWidth * scaleX, // Source Width (scaled to original)\n                selectedElement.cropHeight * scaleY, // Source Height (scaled to original)\n                0, 0, // Destination X, Y\n                selectedElement.cropWidth, // Destination Width (display size)\n                selectedElement.cropHeight // Destination Height (display size)\n                );\n                // Create new image from cropped canvas\n                const newImg = new Image();\n                newImg.onload = () => {\n                    // Store the crop coordinates for later re-editing\n                    const lastCropX = selectedElement.cropX;\n                    const lastCropY = selectedElement.cropY;\n                    const lastCropWidth = selectedElement.cropWidth;\n                    const lastCropHeight = selectedElement.cropHeight;\n                    // Update element with cropped image\n                    // Keep the element at the same position but with new dimensions\n                    this.globalManager.updateElement(selectedElement.id, {\n                        imageElement: newImg,\n                        content: tempCanvas.toDataURL(), // Update the content URL\n                        width: selectedElement.cropWidth,\n                        height: selectedElement.cropHeight,\n                        hasCropApplied: true, // Mark as cropped\n                        lastCropX: lastCropX, // Store last crop coordinates\n                        lastCropY: lastCropY,\n                        lastCropWidth: lastCropWidth,\n                        lastCropHeight: lastCropHeight,\n                        cropX: undefined,\n                        cropY: undefined,\n                        cropWidth: undefined,\n                        cropHeight: undefined\n                    });\n                    // Exit crop mode\n                    this.cropMode = false;\n                    this.canvas.classList.remove('crop-mode');\n                    this.hideCropToolbar();\n                    this.render();\n                };\n                newImg.src = tempCanvas.toDataURL();\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/CanvasManager.ts?\n}");

/***/ }),

/***/ "./src/CanvasSyncManager.ts":
/*!**********************************!*\
  !*** ./src/CanvasSyncManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasSyncManager: () => (/* binding */ CanvasSyncManager)\n/* harmony export */ });\n// Simple and robust canvas synchronization manager\nclass CanvasSyncManager {\n    constructor() {\n        this.syncEnabled = false;\n        this.listeners = new Map();\n        console.log('[SYNC] Canvas Sync Manager initialized');\n    }\n    static getInstance() {\n        if (!CanvasSyncManager.instance) {\n            CanvasSyncManager.instance = new CanvasSyncManager();\n        }\n        return CanvasSyncManager.instance;\n    }\n    // Toggle synchronization globally\n    toggleSync() {\n        this.syncEnabled = !this.syncEnabled;\n        console.log(`[SYNC] Synchronization ${this.syncEnabled ? 'ENABLED' : 'DISABLED'}`);\n        // Notify all canvases about sync state change\n        this.notifyAll();\n        return this.syncEnabled;\n    }\n    isSyncEnabled() {\n        return this.syncEnabled;\n    }\n    // Register a canvas for sync updates\n    registerCanvas(canvasId, updateCallback) {\n        this.listeners.set(canvasId, updateCallback);\n        console.log(`[SYNC] Canvas ${canvasId} registered for sync`);\n    }\n    // Unregister a canvas\n    unregisterCanvas(canvasId) {\n        this.listeners.delete(canvasId);\n        console.log(`[SYNC] Canvas ${canvasId} unregistered from sync`);\n    }\n    // Notify all canvases to update (except the source)\n    notifyCanvasUpdate(sourceCanvasId) {\n        if (!this.syncEnabled)\n            return;\n        console.log(`[SYNC] Notifying all canvases of update from ${sourceCanvasId || 'system'}`);\n        this.listeners.forEach((callback, canvasId) => {\n            // Don't notify the source canvas\n            if (canvasId !== sourceCanvasId) {\n                callback();\n            }\n        });\n    }\n    // Force update all canvases\n    notifyAll() {\n        console.log(`[SYNC] Force updating all canvases`);\n        this.listeners.forEach(callback => callback());\n    }\n    // Get sync status for UI\n    getSyncStatus() {\n        return this.syncEnabled ? 'Sync: ON' : 'Sync: OFF';\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/CanvasSyncManager.ts?\n}");

/***/ }),

/***/ "./src/GlobalElementManager.ts":
/*!*************************************!*\
  !*** ./src/GlobalElementManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalElementManager: () => (/* binding */ GlobalElementManager)\n/* harmony export */ });\nclass GlobalElementManager {\n    constructor() {\n        this.elements = new Map();\n        this.selectedElementId = null;\n        this.changeListeners = new Set();\n        console.log('[GLOBAL] GlobalElementManager initialized');\n    }\n    addElement(element) {\n        console.log(`[GLOBAL] Adding element ${element.id} at global position (${element.x}, ${element.y})`);\n        this.elements.set(element.id, element);\n        this.notifyChange();\n    }\n    // Subscribe to element changes\n    subscribe(callback) {\n        this.changeListeners.add(callback);\n    }\n    // Unsubscribe from element changes\n    unsubscribe(callback) {\n        this.changeListeners.delete(callback);\n    }\n    // Notify all subscribers of changes\n    notifyChange() {\n        console.log(`[GLOBAL] Notifying ${this.changeListeners.size} subscribers of change`);\n        this.changeListeners.forEach(callback => callback());\n    }\n    removeElement(elementId) {\n        if (this.elements.delete(elementId)) {\n            if (this.selectedElementId === elementId) {\n                this.selectedElementId = null;\n            }\n            this.notifyChange();\n        }\n    }\n    getElement(elementId) {\n        return this.elements.get(elementId);\n    }\n    getAllElements() {\n        return Array.from(this.elements.values());\n    }\n    updateElement(elementId, updates) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            Object.assign(element, updates);\n            this.notifyChange();\n        }\n    }\n    getElementsForCanvas(canvasOffsetX, canvasOffsetY, canvasWidth, canvasHeight) {\n        // Return ALL elements when sync is enabled (handled by CanvasSyncManager)\n        // Individual canvas will decide what to render based on sync state\n        const visibleElements = [];\n        this.elements.forEach(element => {\n            // Check if element intersects with this canvas\n            const elementRight = element.x + element.width;\n            const elementBottom = element.y + element.height;\n            const canvasRight = canvasOffsetX + canvasWidth;\n            const canvasBottom = canvasOffsetY + canvasHeight;\n            // Simple intersection check without verbose logging\n            // Check for intersection\n            if (element.x < canvasRight &&\n                elementRight > canvasOffsetX &&\n                element.y < canvasBottom &&\n                elementBottom > canvasOffsetY) {\n                visibleElements.push(element);\n            }\n        });\n        return visibleElements;\n    }\n    setSelectedElement(elementId) {\n        this.selectedElementId = elementId;\n    }\n    getSelectedElement() {\n        if (this.selectedElementId) {\n            return this.elements.get(this.selectedElementId) || null;\n        }\n        return null;\n    }\n    clearAll() {\n        this.elements.clear();\n        this.selectedElementId = null;\n    }\n    duplicateElement(elementId, offsetX = 20, offsetY = 20) {\n        const original = this.elements.get(elementId);\n        if (!original)\n            return null;\n        const duplicate = {\n            ...original,\n            id: `element-${Date.now()}`,\n            x: original.x + offsetX,\n            y: original.y + offsetY\n        };\n        // Clone image element if needed\n        if (duplicate.type === 'image' && original.imageElement) {\n            const img = new Image();\n            img.src = original.imageElement.src;\n            duplicate.imageElement = img;\n        }\n        this.addElement(duplicate);\n        return duplicate;\n    }\n    getElementAtPoint(globalX, globalY) {\n        // Iterate in reverse to get topmost element\n        const elementsArray = Array.from(this.elements.values());\n        for (let i = elementsArray.length - 1; i >= 0; i--) {\n            const element = elementsArray[i];\n            if (globalX >= element.x &&\n                globalX <= element.x + element.width &&\n                globalY >= element.y &&\n                globalY <= element.y + element.height) {\n                return element;\n            }\n        }\n        return null;\n    }\n    moveElementToFront(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            this.elements.delete(elementId);\n            this.elements.set(elementId, element);\n        }\n    }\n    moveElementToBack(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            const allElements = Array.from(this.elements.entries());\n            this.elements.clear();\n            this.elements.set(elementId, element);\n            allElements.forEach(([id, el]) => {\n                if (id !== elementId) {\n                    this.elements.set(id, el);\n                }\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/GlobalElementManager.ts?\n}");

/***/ }),

/***/ "./src/MultiCanvasManager.ts":
/*!***********************************!*\
  !*** ./src/MultiCanvasManager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiCanvasManager: () => (/* binding */ MultiCanvasManager)\n/* harmony export */ });\n/* harmony import */ var _CanvasManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasManager */ \"./src/CanvasManager.ts\");\n/* harmony import */ var _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalElementManager */ \"./src/GlobalElementManager.ts\");\n/* harmony import */ var _CanvasSyncManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasSyncManager */ \"./src/CanvasSyncManager.ts\");\n\n\n\nclass MultiCanvasManager {\n    constructor() {\n        this.canvases = new Map();\n        this.canvasDataMap = new Map();\n        this.activeCanvasId = null;\n        this.canvasCount = 0;\n        this.totalWidth = 0; // Track total width of all canvases\n        this.currentResolution = { width: 800, height: 600 };\n        this.isLinkingEnabled = true; // Keep for backward compatibility\n        this.linkButtons = new Map(); // Store link buttons\n        this.globalElementManager = new _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__.GlobalElementManager();\n        this.syncManager = _CanvasSyncManager__WEBPACK_IMPORTED_MODULE_2__.CanvasSyncManager.getInstance();\n        window.canvasSyncManager = this.syncManager;\n        this.canvasContainer = document.getElementById('canvasContainer');\n        this.thumbnailContainer = document.getElementById('thumbnailContainer');\n        this.setupEventListeners();\n        // Create initial canvas\n        this.addCanvas();\n    }\n    setupEventListeners() {\n        const addCanvasBtn = document.getElementById('addCanvasBtn');\n        const syncToggleBtn = document.getElementById('syncToggleBtn');\n        addCanvasBtn?.addEventListener('click', () => {\n            this.addCanvas();\n        });\n        // Setup sync toggle button\n        syncToggleBtn?.addEventListener('click', () => {\n            const isEnabled = this.syncManager.toggleSync();\n            this.isLinkingEnabled = isEnabled; // Keep backward compatibility\n            syncToggleBtn.textContent = ` : ${isEnabled ? 'ON' : 'OFF'}`;\n            syncToggleBtn.classList.toggle('active', isEnabled);\n        });\n        // Listen for element movement to re-render all canvases\n        document.addEventListener('element-moved', () => {\n            this.renderAllCanvases();\n        });\n        // Listen for canvas click events to activate the clicked canvas\n        document.addEventListener('canvas-clicked', (e) => {\n            const customEvent = e;\n            const canvasId = customEvent.detail?.canvasId;\n            if (canvasId && this.canvases.has(canvasId)) {\n                this.setActiveCanvas(canvasId);\n            }\n        });\n        // Listen for element drag events to handle cross-canvas movement\n        document.addEventListener('element-dragging', (e) => {\n            if (!this.isLinkingEnabled)\n                return;\n            const customEvent = e;\n            const { globalX, globalY } = customEvent.detail;\n            // Find which canvas should be active based on element position\n            this.canvasDataMap.forEach((canvasData, canvasId) => {\n                const isInCanvas = globalX >= canvasData.offsetX &&\n                    globalX < canvasData.offsetX + canvasData.width;\n                if (isInCanvas && this.activeCanvasId !== canvasId) {\n                    this.setActiveCanvas(canvasId);\n                }\n            });\n        });\n    }\n    renderAllCanvases() {\n        this.canvases.forEach(canvas => {\n            canvas.render();\n        });\n    }\n    handleElementOverflow(detail) {\n        const { element, canvasId, bounds } = detail;\n        const sourceCanvas = this.canvases.get(canvasId);\n        if (!sourceCanvas)\n            return;\n        // Get canvas position in container\n        const canvasWrapper = document.getElementById(`wrapper-${canvasId}`);\n        if (!canvasWrapper)\n            return;\n        const canvasRect = canvasWrapper.getBoundingClientRect();\n        const containerRect = this.canvasContainer.getBoundingClientRect();\n        // Check for adjacent canvases\n        this.canvases.forEach((targetCanvas, targetId) => {\n            if (targetId === canvasId)\n                return;\n            const targetWrapper = document.getElementById(`wrapper-${targetId}`);\n            if (!targetWrapper)\n                return;\n            const targetRect = targetWrapper.getBoundingClientRect();\n            // Check if element overflows into this canvas\n            if (this.isOverflowing(canvasRect, targetRect, bounds)) {\n                this.createOverflowElement(element, sourceCanvas, targetCanvas, canvasRect, targetRect);\n            }\n        });\n    }\n    isOverflowing(sourceRect, targetRect, bounds) {\n        // Check horizontal overflow (canvas is to the right)\n        if (targetRect.left >= sourceRect.right - 50 && bounds.right > sourceRect.width) {\n            return true;\n        }\n        // Check horizontal overflow (canvas is to the left)\n        if (targetRect.right <= sourceRect.left + 50 && bounds.left < 0) {\n            return true;\n        }\n        return false;\n    }\n    createOverflowElement(element, sourceCanvas, targetCanvas, sourceRect, targetRect) {\n        // Calculate relative position for the overflow element\n        const relativeX = element.x - (targetRect.left - sourceRect.left);\n        const relativeY = element.y;\n        // Create a temporary visual indicator (you can expand this to actually duplicate elements)\n        console.log('Element overflowing from', sourceCanvas.getCanvas().id, 'to', targetCanvas.getCanvas().id);\n    }\n    addCanvas() {\n        this.canvasCount++;\n        const canvasId = `canvas-${Date.now()}`;\n        const canvasName = ` ${this.canvasCount}`;\n        // Create main wrapper\n        const wrapper = document.createElement('div');\n        wrapper.className = 'canvas-wrapper';\n        wrapper.id = `wrapper-${canvasId}`;\n        // Create title (outside canvas)\n        const title = document.createElement('div');\n        title.className = 'canvas-title';\n        title.contentEditable = 'true';\n        title.textContent = canvasName;\n        title.addEventListener('blur', () => {\n            const data = this.canvasDataMap.get(canvasId);\n            if (data) {\n                data.name = title.textContent || canvasName;\n                this.updateThumbnailLabel(canvasId, data.name);\n            }\n        });\n        // Create canvas content wrapper\n        const canvasContent = document.createElement('div');\n        canvasContent.className = 'canvas-content';\n        // Add click event to canvas content to activate canvas\n        canvasContent.addEventListener('click', (e) => {\n            this.setActiveCanvas(canvasId);\n        });\n        // Create canvas element\n        const canvas = document.createElement('canvas');\n        canvas.id = canvasId;\n        // Assemble the structure: wrapper > [title, canvasContent > canvas]\n        canvasContent.appendChild(canvas);\n        wrapper.appendChild(title);\n        wrapper.appendChild(canvasContent);\n        this.canvasContainer.appendChild(wrapper);\n        // Add link button after this canvas (if not the first canvas)\n        if (this.canvases.size > 0) {\n            this.addLinkButton(canvasId);\n        }\n        // Calculate offset for this canvas based on actual DOM positions\n        // We'll update this after the element is added to DOM\n        let offsetX = this.totalWidth;\n        let offsetY = 0;\n        // Create CanvasManager instance with global manager and offset\n        const canvasManager = new _CanvasManager__WEBPACK_IMPORTED_MODULE_0__.CanvasManager(canvasId, this.globalElementManager, offsetX, offsetY);\n        this.canvases.set(canvasId, canvasManager);\n        // Store canvas data\n        const canvasData = {\n            id: canvasId,\n            name: canvasName,\n            width: this.currentResolution.width,\n            height: this.currentResolution.height,\n            offsetX: offsetX,\n            offsetY: offsetY\n        };\n        this.canvasDataMap.set(canvasId, canvasData);\n        // Set resolution for the new canvas\n        canvasManager.setResolution(this.currentResolution.width, this.currentResolution.height);\n        // Calculate real offset based on canvas widths only, excluding gaps\n        setTimeout(() => {\n            this.recalculateOffsets();\n        }, 0);\n        // Update total width (only canvas widths, no gaps)\n        this.totalWidth += this.currentResolution.width;\n        // Create thumbnail\n        this.createThumbnail(canvasId, canvasName);\n        // Set as active canvas\n        this.setActiveCanvas(canvasId);\n        // Scroll to the new canvas\n        wrapper.scrollIntoView({ behavior: 'smooth', inline: 'end' });\n    }\n    createThumbnail(canvasId, name) {\n        const thumbnailItem = document.createElement('div');\n        thumbnailItem.className = 'thumbnail-item';\n        thumbnailItem.id = `thumb-${canvasId}`;\n        // Create thumbnail canvas\n        const thumbCanvas = document.createElement('canvas');\n        thumbCanvas.className = 'thumbnail-canvas';\n        thumbCanvas.width = 120;\n        thumbCanvas.height = 90;\n        // Create label\n        const label = document.createElement('div');\n        label.className = 'thumbnail-label';\n        label.textContent = name;\n        // Create delete button\n        const deleteBtn = document.createElement('button');\n        deleteBtn.className = 'thumbnail-delete';\n        deleteBtn.innerHTML = '';\n        deleteBtn.onclick = (e) => {\n            e.stopPropagation();\n            this.deleteCanvas(canvasId);\n        };\n        thumbnailItem.appendChild(thumbCanvas);\n        thumbnailItem.appendChild(label);\n        thumbnailItem.appendChild(deleteBtn);\n        // Add click handler\n        thumbnailItem.addEventListener('click', () => {\n            this.setActiveCanvas(canvasId);\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            wrapper?.scrollIntoView({ behavior: 'smooth', inline: 'center' });\n        });\n        this.thumbnailContainer.appendChild(thumbnailItem);\n    }\n    setActiveCanvas(canvasId) {\n        // Remove active class from all\n        document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n            wrapper.classList.remove('active');\n        });\n        document.querySelectorAll('.thumbnail-item').forEach(thumb => {\n            thumb.classList.remove('active');\n        });\n        // Add active class to selected\n        const wrapper = document.getElementById(`wrapper-${canvasId}`);\n        const thumbnail = document.getElementById(`thumb-${canvasId}`);\n        wrapper?.classList.add('active');\n        thumbnail?.classList.add('active');\n        this.activeCanvasId = canvasId;\n        // Update thumbnail\n        this.updateThumbnail(canvasId);\n    }\n    updateThumbnail(canvasId) {\n        const canvasManager = this.canvases.get(canvasId);\n        const thumbnail = document.querySelector(`#thumb-${canvasId} .thumbnail-canvas`);\n        if (canvasManager && thumbnail) {\n            const sourceCanvas = document.getElementById(canvasId);\n            if (sourceCanvas) {\n                const ctx = thumbnail.getContext('2d');\n                if (ctx) {\n                    ctx.clearRect(0, 0, thumbnail.width, thumbnail.height);\n                    // Calculate scale to fit\n                    const scale = Math.min(thumbnail.width / sourceCanvas.width, thumbnail.height / sourceCanvas.height);\n                    const scaledWidth = sourceCanvas.width * scale;\n                    const scaledHeight = sourceCanvas.height * scale;\n                    const x = (thumbnail.width - scaledWidth) / 2;\n                    const y = (thumbnail.height - scaledHeight) / 2;\n                    ctx.drawImage(sourceCanvas, x, y, scaledWidth, scaledHeight);\n                }\n            }\n        }\n    }\n    updateThumbnailLabel(canvasId, name) {\n        const label = document.querySelector(`#thumb-${canvasId} .thumbnail-label`);\n        if (label) {\n            label.textContent = name;\n        }\n    }\n    deleteCanvas(canvasId) {\n        if (this.canvases.size <= 1) {\n            alert('   .');\n            return;\n        }\n        if (confirm('  ?')) {\n            // Remove from maps\n            this.canvases.delete(canvasId);\n            this.canvasDataMap.delete(canvasId);\n            // Remove DOM elements\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            const thumbnail = document.getElementById(`thumb-${canvasId}`);\n            const linkButton = document.getElementById(`link-${canvasId}`);\n            wrapper?.remove();\n            thumbnail?.remove();\n            linkButton?.remove();\n            // Remove from link buttons map\n            this.linkButtons.delete(canvasId);\n            // If this was the active canvas, select another\n            if (this.activeCanvasId === canvasId) {\n                const firstCanvasId = this.canvases.keys().next().value;\n                if (firstCanvasId) {\n                    this.setActiveCanvas(firstCanvasId);\n                }\n            }\n            // Recalculate offsets after deletion\n            setTimeout(() => {\n                this.recalculateOffsets();\n            }, 0);\n        }\n    }\n    getActiveCanvas() {\n        if (this.activeCanvasId) {\n            return this.canvases.get(this.activeCanvasId) || null;\n        }\n        return null;\n    }\n    updateAllThumbnails() {\n        this.canvases.forEach((_, canvasId) => {\n            this.updateThumbnail(canvasId);\n        });\n    }\n    setResolutionForAll(width, height) {\n        this.currentResolution = { width, height };\n        // Reset total width\n        this.totalWidth = 0;\n        // Update each canvas with new resolution\n        this.canvases.forEach((canvasManager, canvasId) => {\n            canvasManager.setResolution(width, height);\n            const canvasData = this.canvasDataMap.get(canvasId);\n            if (canvasData) {\n                canvasData.width = width;\n                canvasData.height = height;\n            }\n        });\n        // Recalculate offsets after resolution change\n        setTimeout(() => {\n            this.recalculateOffsets();\n        }, 0);\n        // Update total width based on actual positions\n        this.updateAllThumbnails();\n    }\n    getActiveCanvasResolution() {\n        if (this.activeCanvasId) {\n            const canvasData = this.canvasDataMap.get(this.activeCanvasId);\n            if (canvasData) {\n                return { width: canvasData.width, height: canvasData.height };\n            }\n        }\n        return null;\n    }\n    addLinkButton(canvasId) {\n        const linkButton = document.createElement('button');\n        linkButton.className = 'canvas-link-button';\n        linkButton.id = `link-${canvasId}`;\n        linkButton.title = ' ';\n        // Create link icon (chain icon)\n        linkButton.innerHTML = `\n            <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n                <path d=\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\"></path>\n                <path d=\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\"></path>\n            </svg>\n        `;\n        // Set initial active state\n        linkButton.classList.add('active');\n        // Toggle linking state\n        linkButton.addEventListener('click', () => {\n            this.isLinkingEnabled = !this.isLinkingEnabled;\n            linkButton.classList.toggle('active', this.isLinkingEnabled);\n            // Update all link buttons to maintain consistent state\n            this.linkButtons.forEach(btn => {\n                btn.classList.toggle('active', this.isLinkingEnabled);\n            });\n            // Notify canvases about linking state change\n            const event = new CustomEvent('linking-state-changed', {\n                detail: { enabled: this.isLinkingEnabled }\n            });\n            document.dispatchEvent(event);\n        });\n        // Insert button before the canvas wrapper\n        const wrapper = document.getElementById(`wrapper-${canvasId}`);\n        if (wrapper && wrapper.parentElement) {\n            wrapper.parentElement.insertBefore(linkButton, wrapper);\n            this.linkButtons.set(canvasId, linkButton);\n        }\n    }\n    isLinkingActive() {\n        return this.syncManager.isSyncEnabled();\n    }\n    recalculateOffsets() {\n        // Calculate offsets based on canvas widths only, not DOM positions\n        // This ensures no gaps in the global coordinate system\n        let currentOffset = 0;\n        const canvasArray = Array.from(this.canvases.entries());\n        canvasArray.forEach(([canvasId, canvasManager], index) => {\n            // Set logical offset (no gaps)\n            canvasManager.setOffset(currentOffset, 0);\n            // Update canvas data\n            const canvasData = this.canvasDataMap.get(canvasId);\n            if (canvasData) {\n                canvasData.offsetX = currentOffset;\n                // Offsets have been updated\n            }\n            // Move to next canvas position (only canvas width, no gap)\n            currentOffset += canvasData?.width || this.currentResolution.width;\n        });\n        // Update total width\n        this.totalWidth = currentOffset;\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/MultiCanvasManager.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultiCanvasManager */ \"./src/MultiCanvasManager.ts\");\n\n\nclass App {\n    constructor() {\n        this.multiCanvasManager = new _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__.MultiCanvasManager();\n        // Make multiCanvasManager globally accessible for canvases\n        window.multiCanvasManager = this.multiCanvasManager;\n        this.setupEventListeners();\n        // Update thumbnails periodically\n        setInterval(() => {\n            this.multiCanvasManager.updateAllThumbnails();\n        }, 1000);\n    }\n    setupEventListeners() {\n        const addTextBtn = document.getElementById('addTextBtn');\n        const imageUpload = document.getElementById('imageUpload');\n        const clearBtn = document.getElementById('clearBtn');\n        const canvasContainer = document.getElementById('canvasContainer');\n        const canvasWidth = document.getElementById('canvasWidth');\n        const canvasHeight = document.getElementById('canvasHeight');\n        const resolutionPreset = document.getElementById('resolutionPreset');\n        addTextBtn?.addEventListener('click', () => {\n            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n            if (activeCanvas) {\n                activeCanvas.addText();\n            }\n        });\n        imageUpload?.addEventListener('change', (e) => {\n            const target = e.target;\n            const file = target.files?.[0];\n            if (file && file.type.startsWith('image/')) {\n                const reader = new FileReader();\n                reader.onload = (event) => {\n                    const imageUrl = event.target?.result;\n                    const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                    if (activeCanvas) {\n                        console.log(`[APP] Adding image to active canvas`);\n                        activeCanvas.addImage(imageUrl);\n                    }\n                    else {\n                        console.error(`[APP] No active canvas to add image to`);\n                    }\n                };\n                reader.readAsDataURL(file);\n            }\n        });\n        clearBtn?.addEventListener('click', () => {\n            if (confirm('  ?')) {\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.clear();\n                }\n            }\n        });\n        // Resolution change handlers\n        const applyResolution = () => {\n            const width = parseInt(canvasWidth.value);\n            const height = parseInt(canvasHeight.value);\n            if (width > 0 && height > 0) {\n                // Set resolution for all canvases to maintain consistency\n                this.multiCanvasManager.setResolutionForAll(width, height);\n            }\n        };\n        canvasWidth?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        canvasHeight?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        resolutionPreset?.addEventListener('change', () => {\n            const value = resolutionPreset.value;\n            if (value !== 'custom') {\n                const [width, height] = value.split('x').map(Number);\n                canvasWidth.value = width.toString();\n                canvasHeight.value = height.toString();\n                applyResolution();\n            }\n        });\n        // Crop button\n        const cropBtn = document.getElementById('cropBtn');\n        cropBtn?.addEventListener('click', () => {\n            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n            if (activeCanvas) {\n                activeCanvas.startCropMode();\n            }\n        });\n        // Show/hide crop button when image is selected\n        document.addEventListener('selection-changed', (e) => {\n            const customEvent = e;\n            const selectedElement = customEvent.detail?.element;\n            if (cropBtn) {\n                cropBtn.style.display = selectedElement?.type === 'image' ? 'block' : 'none';\n            }\n        });\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Delete' || e.key === 'Backspace') {\n                //      \n                const textEditor = document.querySelector('.text-editor-active');\n                if (textEditor) {\n                    console.log(' [Global Delete/Backspace] Text editor is active, ignoring delete');\n                    return; //   \n                }\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.deleteSelected();\n                }\n            }\n        });\n        // Drag and drop for images\n        canvasContainer?.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.add('dragging');\n        });\n        canvasContainer?.addEventListener('dragleave', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.remove('dragging');\n        });\n        canvasContainer?.addEventListener('drop', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.remove('dragging');\n            const files = e.dataTransfer?.files;\n            if (files) {\n                for (let i = 0; i < files.length; i++) {\n                    const file = files[i];\n                    if (file.type.startsWith('image/')) {\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            const imageUrl = event.target?.result;\n                            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                            if (activeCanvas) {\n                                activeCanvas.addImage(imageUrl);\n                            }\n                        };\n                        reader.readAsDataURL(file);\n                    }\n                }\n            }\n        });\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    new App();\n});\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/index.ts?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/styles.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;